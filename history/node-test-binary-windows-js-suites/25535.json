{"failedTests":[{"testName":"sequential/test-http2-large-file","timestamp":1705971566279,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 2,win2022-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=2,nodes=win2022-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-rackspace-win2022_vs2022-x64-3","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":{"ok":false,"name":"sequential/test-http2-large-file","id":950,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":1,"stack":"timeout"},"time":120203.203,"fullname":"sequential/test-http2-large-file","closingTestPoint":false}},{"testName":"parallel/test-child-process-exec-maxbuf","timestamp":1705971566279,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 3,win2019-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=3,nodes=win2019-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-rackspace-win2019_vs2019-x64-3","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":{"ok":false,"name":"parallel/test-child-process-exec-maxbuf","id":98,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":1,"stack":"node:internal/child_process:421\n    throw new ErrnoException(err, 'spawn');\n    ^\n\nError: spawn UNKNOWN\n    at ChildProcess.spawn (node:internal/child_process:421:11)\n    at spawn (node:child_process:761:9)\n    at Object.execFile (node:child_process:351:17)\n    at Object.exec (node:child_process:234:25)\n    at Object.<anonymous> (C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\parallel\\test-child-process-exec-maxbuf.js:49:6)\n    at Module._compile (node:internal/modules/cjs/loader:1378:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1437:10)\n    at Module.load (node:internal/modules/cjs/loader:1212:32)\n    at Module._load (node:internal/modules/cjs/loader:1028:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:142:12) {\n  errno: -4094,\n  code: 'UNKNOWN',\n  syscall: 'spawn'\n}\n\nNode.js v22.0.0-pre"},"time":456.001,"fullname":"parallel/test-child-process-exec-maxbuf","closingTestPoint":false}},{"testName":"parallel/test-child-process-exec-encoding","timestamp":1705971566279,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 3,win2019-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=3,nodes=win2019-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-rackspace-win2019_vs2019-x64-3","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":{"ok":false,"name":"parallel/test-child-process-exec-encoding","id":99,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":1,"stack":"node:assert:1000\n    throw newErr;\n    ^\n\nAssertionError [ERR_ASSERTION]: ifError got unwanted exception: Command failed: \"C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe\" \"C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\parallel\\test-child-process-exec-encoding.js\" child\n\n\n<--- Last few GCs --->\n\n\n\n\n\n<--- JS stacktrace --->\n\n\n\n\n\n#\n\n# Fatal JavaScript out of memory: MemoryChunk allocation failed during deserialization.\n\n#\n\n\n\n\n    at C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\index.js:439:12\n    at C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\index.js:476:15\n    at ChildProcess.exithandler (node:child_process:430:5)\n    at genericNodeError (node:internal/errors:984:15)\n    at wrappedFn (node:internal/errors:538:14)\n    at ChildProcess.exithandler (node:child_process:422:12)\n    at ChildProcess.emit (node:events:519:28)\n    at maybeClose (node:internal/child_process:1105:16)\n    at ChildProcess._handle.onexit (node:internal/child_process:305:5) {\n  generatedMessage: false,\n  code: 'ERR_ASSERTION',\n  actual: Error: Command failed: \"C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe\" \"C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\parallel\\test-child-process-exec-encoding.js\" child\n  \n\n  <--- Last few GCs --->\n\n  \n\n  \n\n  <--- JS stacktrace --->\n\n  \n\n  \n\n  #\n\n  # Fatal JavaScript out of memory: MemoryChunk allocation failed during deserialization.\n\n  #\n\n  \n\n  \n      at genericNodeError (node:internal/errors:984:15)\n      at wrappedFn (node:internal/errors:538:14)\n      at ChildProcess.exithandler (node:child_process:422:12)\n      at ChildProcess.emit (node:events:519:28)\n      at maybeClose (node:internal/child_process:1105:16)\n      at ChildProcess._handle.onexit (node:internal/child_process:305:5) {\n    code: 2147483651,\n    killed: false,\n    signal: null,\n    cmd: '\"C:\\\\workspace\\\\node-test-binary-windows-js-suites\\\\node\\\\Release\\\\node.exe\" \"C:\\\\workspace\\\\node-test-binary-windows-js-suites\\\\node\\\\test\\\\parallel\\\\test-child-process-exec-encoding.js\" child'\n  },\n  expected: null,\n  operator: 'ifError'\n}\n\nNode.js v22.0.0-pre"},"time":626,"fullname":"parallel/test-child-process-exec-encoding","closingTestPoint":false}},{"testName":"test/Test 969 missing","timestamp":1705971566279,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 3,win2019-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=3,nodes=win2019-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-rackspace-win2019_vs2019-x64-3","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":null},{"testName":"wpt/test-streams","timestamp":1705971566279,"status":"REGRESSION","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 1,win2019-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=1,nodes=win2019-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-rackspace-win2019_vs2019-x64-2","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":{"ok":false,"name":"wpt/test-streams","id":968,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"crashed","exitcode":3221225477,"stack":"[SKIPPED] idlharness-shadowrealm.window.js: ShadowRealm support is not enabled\n[SKIPPED] queuing-strategies-size-function-per-global.window.js: Browser-specific test\n[SKIPPED] readable-streams\\cross-realm-crash.window.js: Browser-specific test\n[SKIPPED] readable-streams\\owning-type-video-frame.any.js: Browser-specific test\n[SKIPPED] readable-streams\\read-task-handling.window.js: Browser-specific test\n[SKIPPED] transferable\\deserialize-error.window.js: Browser-specific test\n[SKIPPED] transferable\\transfer-with-messageport.window.js: Browser-specific test\n[SKIPPED] transform-streams\\invalid-realm.tentative.window.js: Browser-specific test\n[PASS] a signal argument 'null' should cause pipeTo() to reject\n[PASS] a signal argument 'AbortSignal' should cause pipeTo() to reject\n[PASS] a signal argument 'true' should cause pipeTo() to reject\n[PASS] a signal argument '-1' should cause pipeTo() to reject\n[PASS] a signal argument '[object AbortSignal]' should cause pipeTo() to reject\n[PASS] an aborted signal should cause the writable stream to reject with an AbortError\n[PASS] (reason: 'null') all the error objects should be the same object\n[PASS] (reason: 'undefined') all the error objects should be the same object\n[PASS] (reason: 'error1: error1') all the error objects should be the same object\n[PASS] preventCancel should prevent canceling the readable\n[PASS] preventAbort should prevent aborting the readable\n[PASS] preventCancel and preventAbort should prevent canceling the readable and aborting the readable\n[PASS] (reason: 'null') abort should prevent further reads\n[PASS] (reason: 'undefined') abort should prevent further reads\n[PASS] (reason: 'error1: error1') abort should prevent further reads\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; rejected cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = a (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 1 (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = Symbol() (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = [object Object] (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = undefined (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = null (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = false (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = 0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = -0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = NaN (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose =  (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = true (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = a (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = 1 (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = Symbol() (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = [object Object] (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true, preventCancel = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = undefined (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = null (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = -0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = NaN (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort =  (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = a (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 1 (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = Symbol() (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = [object Object] (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true, preventClose = true\n[PASS] Errors must be propagated backward: starts errored; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] (reason: 'null') all pending writes should complete on abort\n[PASS] (reason: 'undefined') all pending writes should complete on abort\n[PASS] (reason: 'error1: error1') all pending writes should complete on abort\n[PASS] a rejection from underlyingSource.cancel() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()\n[PASS] abort signal takes priority over closed readable\n[PASS] abort signal takes priority over errored readable\n[PASS] abort signal takes priority over closed writable\n[PASS] abort signal takes priority over errored writable\n[PASS] abort should do nothing after the readable is closed\n[PASS] abort should do nothing after the readable is errored\n[PASS] abort should do nothing after the readable is errored, even with pending writes\n[PASS] abort should do nothing after the writable is errored\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose = true\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = a (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 1 (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = Symbol() (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = [object Object] (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write, preventCancel = true; preventAbort = true\n[PASS] pipeTo on a teed readable byte stream should only be aborted when both branches are aborted\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel = true\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = true\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = true\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; rejected close promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose = true\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; rejected cancel promise\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks, but then does\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Piping from an empty ReadableStream into a WritableStream that does not desire chunks, but then the readable stream becomes non-empty and the writable stream starts desiring chunks\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel = true\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel omitted (but cancel is never called)\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel = true\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = true\n[PASS] Piping from a ReadableStream to a WritableStream that desires more chunks before finishing with previous ones\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write; preventClose = true\n[PASS] idl_test validation\n[PASS] Closing must be propagated forward: erroring the writable while flushing pending writes should error pipeTo\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel = true\n[PASS] Errors must be propagated backward: erroring via the controller errors once pending write completes\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; rejected abort promise\n[PASS] ReadableStreamDefaultReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStreamBYOBReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStream interface: existence and properties of interface object\n[PASS] ReadableStream interface object length\n[PASS] ReadableStream interface object name\n[PASS] ReadableStream interface: existence and properties of interface prototype object\n[PASS] ReadableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStream interface: operation from(any)\n[PASS] ReadableStream interface: operation getReader(optional ReadableStreamGetReaderOptions)\n[PASS] ReadableStream interface: operation pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\n[PASS] ReadableStream interface: operation tee()\n[PASS] ReadableStream interface: async iterable<any>\n[PASS] ReadableStream must be primary interface of new ReadableStream()\n[PASS] Stringification of new ReadableStream()\n[EXPECTED_FAILURE][FAIL] enqueue() must not synchronously call write algorithm\nassert_false: write algorithm must not run synchronously expected false got true\n    at Test.<anonymous> (C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\fixtures\\wpt\\streams\\piping\\general-addition.any.js:14:3)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'piping\\general-addition.any.js'\n\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"from(any)\" with the proper type\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = true\n[PASS] ReadableStream interface: calling from(any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"locked\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStream interface: calling cancel(optional any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"getReader(optional ReadableStreamGetReaderOptions)\" with the proper type\n[PASS] ReadableStream interface: calling getReader(optional ReadableStreamGetReaderOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: calling pipeThrough(ReadableWritablePair, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeTo(WritableStream, optional StreamPipeOptions)\" with the proper type\n[PASS] Piping to a WritableStream that does not consume the writes fast enough exerts backpressure on the ReadableStream\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"tee()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultReader interface object length\n[PASS] ReadableStreamDefaultReader interface object name\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultReader interface: operation releaseLock()\n[PASS] ReadableStreamDefaultReader must be primary interface of (new ReadableStream()).getReader()\n[PASS] Stringification of (new ReadableStream()).getReader()\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"read()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: calling cancel(optional any) on (new ReadableStream()).getReader() with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBReader interface object length\n[PASS] ReadableStreamBYOBReader interface object name\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBReader interface: operation releaseLock()\n[PASS] ReadableStreamBYOBReader must be primary interface of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] Stringification of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"read(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: calling cancel(optional any) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultController interface object length\n[PASS] ReadableStreamDefaultController interface object name\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultController interface: operation close()\n[PASS] ReadableStreamDefaultController interface: operation enqueue(optional any)\n[PASS] ReadableStreamDefaultController interface: operation error(optional any)\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] ReadableStreamDefaultController must be primary interface of self.readableStreamDefaultController\n[PASS] Stringification of self.readableStreamDefaultController\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"close()\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling enqueue(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling error(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: existence and properties of interface object\n[PASS] ReadableByteStreamController interface object length\n[PASS] ReadableByteStreamController interface object name\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableByteStreamController interface: operation close()\n[PASS] ReadableByteStreamController interface: operation enqueue(ArrayBufferView)\n[PASS] ReadableByteStreamController interface: operation error(optional any)\n[PASS] ReadableByteStreamController must be primary interface of self.readableByteStreamController\n[PASS] Stringification of self.readableByteStreamController\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"byobRequest\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"close()\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"enqueue(ArrayBufferView)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling enqueue(ArrayBufferView) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling error(optional any) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBRequest interface object length\n[PASS] ReadableStreamBYOBRequest interface object name\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBRequest interface: operation respond(unsigned long long)\n[PASS] ReadableStreamBYOBRequest interface: operation respondWithNewView(ArrayBufferView)\n[PASS] ReadableStreamBYOBRequest must be primary interface of self.readableStreamByobRequest\n[PASS] Stringification of self.readableStreamByobRequest\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"view\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respond(unsigned long long)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respond(unsigned long long) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respondWithNewView(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respondWithNewView(ArrayBufferView) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] WritableStream interface: existence and properties of interface object\n[PASS] WritableStream interface object length\n[PASS] WritableStream interface object name\n[PASS] WritableStream interface: existence and properties of interface prototype object\n[PASS] WritableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStream interface: operation getWriter()\n[PASS] WritableStream must be primary interface of new WritableStream()\n[PASS] Stringification of new WritableStream()\n[PASS] WritableStream interface: new WritableStream() must inherit property \"locked\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStream interface: calling abort(optional any) on new WritableStream() with too few arguments must throw TypeError\n[PASS] WritableStream interface: new WritableStream() must inherit property \"close()\" with the proper type\n[PASS] Piping must lock both the ReadableStream and WritableStream\n[PASS] WritableStream interface: new WritableStream() must inherit property \"getWriter()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface object\n[PASS] WritableStreamDefaultWriter interface object length\n[PASS] WritableStreamDefaultWriter interface object name\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] WritableStreamDefaultWriter interface: operation releaseLock()\n[PASS] WritableStreamDefaultWriter must be primary interface of (new WritableStream()).getWriter()\n[PASS] Stringification of (new WritableStream()).getWriter()\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"closed\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"desiredSize\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"ready\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling abort(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"close()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"releaseLock()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"write(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling write(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultController interface: existence and properties of interface object\n[PASS] WritableStreamDefaultController interface object length\n[PASS] WritableStreamDefaultController interface object name\n[PASS] Piping finishing must unlock both the ReadableStream and WritableStream\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] pipeTo must check the brand of its ReadableStream this value\n[PASS] pipeTo must check the brand of its WritableStream argument\n[PASS] WritableStreamDefaultController interface: operation error(optional any)\n[PASS] WritableStreamDefaultController must be primary interface of self.writableStreamDefaultController\n[PASS] Stringification of self.writableStreamDefaultController\n[PASS] pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"signal\" with the proper type\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] WritableStreamDefaultController interface: calling error(optional any) on self.writableStreamDefaultController with too few arguments must throw TypeError\n[PASS] pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream\n[PASS] TransformStream interface: existence and properties of interface object\n[PASS] TransformStream interface object length\n[PASS] TransformStream interface object name\n[PASS] TransformStream interface: existence and properties of interface prototype object\n[PASS] TransformStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStream must be primary interface of new TransformStream()\n[PASS] Stringification of new TransformStream()\n[PASS] TransformStream interface: new TransformStream() must inherit property \"readable\" with the proper type\n[PASS] TransformStream interface: new TransformStream() must inherit property \"writable\" with the proper type\n[PASS] TransformStreamDefaultController interface: existence and properties of interface object\n[PASS] TransformStreamDefaultController interface object length\n[PASS] TransformStreamDefaultController interface object name\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] Piping from a ReadableStream from which lots of chunks are synchronously readable\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStreamDefaultController interface: operation enqueue(optional any)\n[PASS] TransformStreamDefaultController interface: operation error(optional any)\n[PASS] TransformStreamDefaultController interface: operation terminate()\n[PASS] TransformStreamDefaultController must be primary interface of self.transformStreamDefaultController\n[PASS] Stringification of self.transformStreamDefaultController\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling enqueue(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling error(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"terminate()\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface object\n[PASS] ByteLengthQueuingStrategy interface object length\n[PASS] ByteLengthQueuingStrategy interface object name\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ByteLengthQueuingStrategy must be primary interface of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] CountQueuingStrategy interface: existence and properties of interface object\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = true\n[PASS] CountQueuingStrategy interface object length\n[PASS] CountQueuingStrategy interface object name\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] CountQueuingStrategy must be primary interface of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] ReadableStream interface: attribute locked\n[PASS] ReadableStreamDefaultController interface: attribute desiredSize\n[PASS] ReadableByteStreamController interface: attribute byobRequest\n[PASS] ReadableByteStreamController interface: attribute desiredSize\n[PASS] ReadableStreamBYOBRequest interface: attribute view\n[PASS] WritableStream interface: attribute locked\n[PASS] WritableStreamDefaultWriter interface: attribute desiredSize\n[PASS] WritableStreamDefaultController interface: attribute signal\n[PASS] TransformStream interface: attribute readable\n[PASS] TransformStream interface: attribute writable\n[PASS] TransformStreamDefaultController interface: attribute desiredSize\n[PASS] ByteLengthQueuingStrategy interface: attribute highWaterMark\n[PASS] ByteLengthQueuingStrategy interface: attribute size\n[PASS] CountQueuingStrategy interface: attribute highWaterMark\n[PASS] CountQueuingStrategy interface: attribute size\n[PASS] idl_test setup\n[PASS] ReadableStream interface: operation cancel(optional any)\n[PASS] ReadableStream interface: operation pipeTo(WritableStream, optional StreamPipeOptions)\n[PASS] ReadableStream interface: calling pipeTo(WritableStream, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultReader interface: operation read()\n[PASS] ReadableStreamDefaultReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: operation read(ArrayBufferView)\n[PASS] ReadableStreamBYOBReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: calling read(ArrayBufferView) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] WritableStream interface: operation abort(optional any)\n[PASS] WritableStream interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation abort(optional any)\n[PASS] WritableStreamDefaultWriter interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation write(optional any)\n[PASS] ReadableStreamDefaultReader interface: attribute closed\n[PASS] ReadableStreamBYOBReader interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute ready\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; preventAbort = true\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is true\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is false\n[PASS] pipeTo() should reject if an option getter grabs a writer\n[PASS] pipeTo() promise should resolve if null is passed\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write\n[PASS] Piping from an errored readable stream to an erroring writable stream\n[PASS] Piping from an errored readable stream to an errored writable stream\n[PASS] Piping from an errored readable stream to an erroring writable stream; preventAbort = true\n[PASS] Piping from an errored readable stream to an errored writable stream; preventAbort = true\n[PASS] Piping from an errored readable stream to a closing writable stream\n[PASS] pipeThrough should not call pipeTo on this\n[PASS] pipeThrough should not call pipeTo on the ReadableStream prototype\n[PASS] pipeThrough should brand-check this and not allow 'null'\n[PASS] Piping from an errored readable stream to a closed writable stream\n[PASS] pipeThrough should brand-check readable and not allow 'null'\n[PASS] pipeThrough should brand-check this and not allow 'undefined'\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write; preventAbort = true\n[PASS] pipeThrough should brand-check readable and not allow 'undefined'\n[PASS] Piping from a closed readable stream to an erroring writable stream\n[PASS] pipeThrough should brand-check this and not allow '0'\n[PASS] pipeThrough should brand-check readable and not allow '0'\n[PASS] Piping from a closed readable stream to an errored writable stream\n[PASS] pipeThrough should brand-check this and not allow 'NaN'\n[PASS] pipeThrough should brand-check readable and not allow 'NaN'\n[PASS] pipeThrough should brand-check this and not allow 'true'\n[PASS] pipeThrough should brand-check readable and not allow 'true'\n[PASS] pipeThrough should brand-check this and not allow 'ReadableStream'\n[PASS] Piping from a closed readable stream to a closed writable stream\n[PASS] pipeThrough should brand-check readable and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check this and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check readable and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check writable and not allow 'null'\n[PASS] pipeThrough should brand-check writable and not allow 'undefined'\n[PASS] pipeThrough should brand-check writable and not allow '0'\n[PASS] pipeThrough should brand-check writable and not allow 'NaN'\n[PASS] pipeThrough should brand-check writable and not allow 'true'\n[PASS] pipeThrough should brand-check writable and not allow 'WritableStream'\n[PASS] pipeThrough should brand-check writable and not allow '[object WritableStream]'\n[PASS] pipeThrough should rethrow errors from accessing readable or writable\n[PASS] invalid values of signal should throw; specifically 'null'\n[PASS] invalid values of signal should throw; specifically '0'\n[PASS] invalid values of signal should throw; specifically 'NaN'\n[PASS] invalid values of signal should throw; specifically 'true'\n[PASS] invalid values of signal should throw; specifically 'AbortSignal'\n[PASS] invalid values of signal should throw; specifically '[object AbortSignal]'\n[PASS] pipeThrough should accept a real AbortSignal\n[PASS] pipeThrough should throw if this is locked\n[PASS] pipeThrough should throw if writable is locked\n[PASS] pipeThrough should not care if readable is locked\n[PASS] pipeThrough() should throw if an option getter grabs a writer\n[PASS] pipeThrough() should not throw if option is null\n[PASS] pipeThrough() should not throw if signal is undefined\n[PASS] pipeThrough() should throw if readable/writable getters throw\n[PASS] pipeThrough should stop after getting preventAbort throws\n[PASS] pipeThrough should stop after getting preventCancel throws\n[PASS] pipeThrough should stop after getting preventClose throws\n[PASS] pipeThrough should stop after getting signal throws\n[PASS] piping should not be observable\n[PASS] Piping through a duck-typed pass-through transform stream should work\n[PASS] pipeTo should stop after getting preventAbort throws\n[PASS] pipeTo should stop after getting preventCancel throws\n[PASS] tee should not be observable\n[PASS] pipeTo should stop after getting preventClose throws\n[PASS] pipeTo should stop after getting signal throws\n[PASS] Piping through a transform errored on the writable end does not cause an unhandled promise rejection\n[PASS] preventCancel should work\n[PASS] preventClose should work\n[PASS] preventAbort should work\n[PASS] CountQueuingStrategy: Can construct a with a valid high water mark\n[PASS] CountQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] CountQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] CountQueuingStrategy: size is the same function across all instances\n[PASS] CountQueuingStrategy: size should have the right name\n[PASS] CountQueuingStrategy: subclassing should work correctly\n[PASS] CountQueuingStrategy: size should not have a prototype property\n[PASS] ByteLengthQueuingStrategy: Can construct a with a valid high water mark\n[PASS] ByteLengthQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] ByteLengthQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] ByteLengthQueuingStrategy: size is the same function across all instances\n[PASS] ByteLengthQueuingStrategy: size should have the right name\n[PASS] ByteLengthQueuingStrategy: subclassing should work correctly\n[PASS] ByteLengthQueuingStrategy: size should not have a prototype property\n[PASS] CountQueuingStrategy: size should not be a constructor\n[PASS] ByteLengthQueuingStrategy: size should not be a constructor\n[PASS] CountQueuingStrategy: size should have the right length\n[PASS] ByteLengthQueuingStrategy: size should have the right length\n[PASS] Piping through an identity transform stream should close the destination when the source closes\n[PASS] CountQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ByteLengthQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: enqueuing an already-detached buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length view on a non-zero-length buffer throws\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is zero-length on a non-zero-length buffer (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (autoAllocateChunkSize)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a larger length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is non-zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the closed state)\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: read()ing from a closed stream still transfers the buffer\n[PASS] enqueue after detaching byobRequest.view.buffer should throw\n[PASS] ReadableStream with byte source: read()ing from a stream with queued chunks still transfers the buffer\n[PASS] ReadableStream with byte source: reading into an already-detached buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length view on a non-zero-length buffer rejects\n[PASS] getReader({mode: \"byob\"}) throws on non-bytes streams\n[PASS] ReadableStream with byte source can be constructed with no errors\n[PASS] getReader({mode}) must perform ToString()\n[PASS] ReadableStream with byte source: start() throws an exception\n[PASS] ReadableStream with byte source: enqueue() with a non-transferable buffer\n[PASS] ReadableStream with byte source: desiredSize when closed\n[PASS] ReadableStream with byte source: desiredSize when errored\n[PASS] ReadableStream with byte source: pull() function is not callable\n[PASS] ReadableStream with byte source: read() with a non-transferable buffer\n[PASS] ReadableStream with byte source: fill() with a non-transferable buffer\n[PASS] ReadableStream with byte source: Throw if close()-ed more than once\n[PASS] ReadableStream with byte source: Throw on enqueue() after close()\n[PASS] ReadableStream with byte source: respondWithNewView() with a non-transferable buffer\n[PASS] ReadableStream with byte source: autoAllocateChunkSize cannot be 0\n[PASS] ReadableStreamBYOBReader can be constructed directly\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream argument\n[PASS] ReadableStreamBYOBReader constructor requires an unlocked ReadableStream\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream with type \"bytes\"\n[PASS] ReadableStream constructor should not accept a strategy with a size defined if type is \"bytes\"\n[PASS] ReadableStream with byte source: Construct and expect start and pull being called\n[PASS] ReadableStream with byte source: No automatic pull call if start doesn't finish\n[PASS] ReadableStream with byte source: Construct with highWaterMark of 0\n[PASS] ReadableStream with byte source: getReader(), then releaseLock()\n[PASS] ReadableStream with byte source: getReader() with mode set to byob, then releaseLock()\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: releaseLock() on ReadableStreamDefaultReader must reject pending read()\n[PASS] ReadableStream with byte source: releaseLock() on ReadableStreamBYOBReader must reject pending read()\n[PASS] ReadableStream with byte source: Automatic pull() after start()\n[PASS] ReadableStream with byte source: Automatic pull() after start() and read()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize\n[PASS] ReadableStream with byte source: Mix of auto allocate and BYOB\n[PASS] ReadableStream with byte source: Automatic pull() after start() and read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read()\n[PASS] ReadableStream with byte source: Push source that doesn't understand pull signal\n[PASS] ReadableStream with byte source: enqueue() with Uint16Array, getReader(), then read()\n[PASS] ReadableStream with byte source: enqueue(), read(view) partially, then read()\n[PASS] ReadableStream with byte source: getReader(), enqueue(), close(), then read()\n[PASS] ReadableStream with byte source: enqueue(), close(), getReader(), then read()\n[PASS] ReadableStream with byte source: Respond to pull() by enqueue()\n[PASS] ReadableStream with byte source: Respond to pull() by enqueue() asynchronously\n[PASS] ReadableStream with byte source: Respond to multiple pull() by separate enqueue()\n[PASS] ReadableStream with byte source: read(view), then respond()\n[PASS] ReadableStream with byte source: read(view), then respondWithNewView() with a transferred ArrayBuffer\n[PASS] ReadableStream with byte source: read(view), then respond() with too big value\n[PASS] ReadableStream with byte source: respond(3) to read(view) with 2 element Uint16Array enqueues the 1 byte remainder\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = not BYOB)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = BYOB)\n[PASS] ReadableStream with byte source: getReader(), read(view), then cancel()\n[PASS] ReadableStream with byte source: cancel() with partially filled pending pull() request\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) where view.buffer is not fully covered by view\n[PASS] ReadableStream with byte source: Multiple enqueue(), getReader(), then read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) with a bigger view\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) with smaller views\n[PASS] ReadableStream with byte source: enqueue() 1 byte, getReader(), then read(view) with Uint16Array\n[PASS] ReadableStream with byte source: enqueue() 3 byte, getReader(), then read(view) with 2-element Uint16Array\n[PASS] ReadableStream with byte source: read(view) with Uint16Array on close()-d stream with 1 byte enqueue()-d must fail\n[PASS] ReadableStream with byte source: A stream must be errored if close()-d before fulfilling read(view) with Uint16Array\n[PASS] ReadableStream with byte source: read(view), then respond() and close() in pull()\n[PASS] ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple respond() calls\n[PASS] ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple enqueue() calls\n[PASS] ReadableStream with byte source: read() twice, then enqueue() twice\n[PASS] ReadableStream with byte source: Multiple read(view), close() and respond()\n[PASS] ReadableStream with byte source: Multiple read(view), big enqueue()\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is 0\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is negative\n[PASS] ReadableStream with byte source: Multiple read(view) and multiple enqueue()\n[PASS] ReadableStream with byte source: read(view) with passing undefined as view must fail\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint8Array)\n[PASS] ReadableStream with byte source: read(view) with passing an empty object as view must fail\n[PASS] ReadableStream with byte source: Even read(view) with passing ArrayBufferView like object as view must fail\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint16Array)\n[PASS] ReadableStream with byte source: read() on an errored stream\n[PASS] ReadableStream with byte source: read(), then error()\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (DataView)\n[PASS] ReadableStream with byte source: read(view) on an errored stream\n[PASS] byobRequest.respond() after enqueue() should not crash\n[PASS] ReadableStream with byte source: read(view), then error()\n[PASS] ReadableStream with byte source: Throwing in pull function must error the stream\n[PASS] ReadableStream with byte source: Throwing in pull in response to read() must be ignored if the stream is errored in it\n[PASS] byobRequest.respond() with cached byobRequest after enqueue() should not crash\n[PASS] ReadableStream with byte source: Throwing in pull in response to read(view) function must error the stream\n[PASS] ReadableStream with byte source: Throwing in pull in response to read(view) must be ignored if the stream is errored in it\n[PASS] byobRequest.respond() after enqueue() with double read should not crash\n[PASS] calling respond() twice on the same byobRequest should throw\n[PASS] calling respondWithNewView() twice on the same byobRequest should throw\n[PASS] ReadableStream with byte source: read({ min }), then read()\n[PASS] ReadableStream with byte source: read({ min }) with a DataView\n[PASS] calling respond(0) twice on the same byobRequest should throw even when closed\n[PASS] calling respond() should throw when canceled\n[PASS] ReadableStream with byte source: enqueue(), then read({ min })\n[PASS] pull() resolving should not resolve read()\n[PASS] ReadableStream with byte source: default reader + autoAllocateChunkSize + byobRequest interaction\n[PASS] ReadableStream with byte source: respondWithNewView() with a smaller view\n[PASS] ReadableStream with byte source: respondWithNewView() with a zero-length view (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() with a transferred non-zero-length view (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() with a transferred zero-length view (in the closed state)\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 3-byte Uint8Array, then multiple enqueue() up to 3 bytes\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 3 bytes\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 4 bytes\n[PASS] ReadableStream with byte source: enqueue(), read({ min }) partially, then read()\n[PASS] ReadableStream with byte source: read({ min }), then respondWithNewView() with a transferred ArrayBuffer\n[PASS] ReadableStream with byte source: read({ min }) on a closed stream\n[PASS] ReadableStream with byte source: read({ min }) when closed before view is filled\n[PASS] ReadableStream with byte source: enqueue() discards auto-allocated BYOB request\n[PASS] ReadableStream with byte source: read({ min }) when closed immediately after view is filled\n[PASS] ReadableStream with byte source: read({ min }) on an errored stream\n[PASS] ReadableStream with byte source: read({ min }), then error()\n[PASS] ReadableStream with byte source: getReader(), read({ min }), then cancel()\n[PASS] ReadableStream with byte source: cancel() with partially filled pending read({ min }) request\n[PASS] ReadableStream with byte source: enqueue(), then read({ min }) with smaller views\n[PASS] ReadableStream with byte source: 3 byte enqueue(), then close(), then read({ min }) with 2-element Uint16Array must fail\n[PASS] ReadableStream with byte source: read({ min }) with 2-element Uint16Array, then 3 byte enqueue(), then close() must fail\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respond()\n[PASS] ReadableStream with byte source: tee() with read({ min }) from branch1 and read() from branch2\n[PASS] ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams\n[PASS] Running templatedRSTeeCancel with ReadableStream teeing with byte source\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 1 element Uint16Array, respond(1)\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 2 element Uint8Array, respond(3)\n[PASS] ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other\n[PASS] Readable stream: throwing strategy.size getter\n[PASS] Readable stream: throwing strategy.highWaterMark getter\n[PASS] ReadableStream teeing with byte source: chunks should be cloned for each branch\n[PASS] Async iterator instances should have the correct list of properties\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respondWithNewView()\n[PASS] ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2\n[PASS] Readable stream: invalid strategy.highWaterMark\n[PASS] values() throws if there's already a lock\n[PASS] ReadableStream teeing with byte source: errors in the source should propagate to both branches\n[PASS] return() should unlock the stream synchronously when preventCancel = false\n[PASS] Readable stream: strategy.size errors the stream and then throws\n[PASS] return() should unlock the stream synchronously when preventCancel = true\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, enqueue()\n[PASS] ReadableStream teeing with byte source: canceling branch1 should not impact branch2\n[PASS] Readable stream: strategy.size errors the stream and then returns Infinity\n[PASS] Readable stream: throwing strategy.size method\n[PASS] ReadableStream teeing with byte source: canceling branch2 should not impact branch1\n[PASS] Async-iterating a push source\n[PASS] ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array\n[PASS] Readable stream: invalid strategy.size return value\n[PASS] Async-iterating a pull source\n[PASS] ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array\n[PASS] ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches\n[PASS] Async-iterating a push source with undefined values\n[PASS] ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches\n[PASS] Readable stream: invalid strategy.size return value when pulling\n[PASS] Async-iterating a pull source with undefined values\n[PASS] ReadableStream teeing with byte source: closing the original should close the branches\n[PASS] ReadableStream teeing with byte source: erroring the original should immediately error the branches\n[PASS] ReadableStream teeing with byte source: erroring the original should error pending reads from default reader\n[PASS] Async-iterating a pull source manually\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, close(), respond(0)\n[PASS] ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader\n[PASS] Async-iterating an errored stream throws\n[PASS] ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream\n[PASS] Async-iterating a closed stream never executes the loop body, but works fine\n[PASS] ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors\n[PASS] Underlying source start: throwing getter\n[PASS] Underlying source start: throwing method\n[PASS] Underlying source: throwing pull getter (initial pull)\n[PASS] Underlying source cancel: throwing getter\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, respond()\n[PASS] Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function\n[PASS] ReadableStream teeing with byte source: should not pull any chunks if no branches are reading\n[PASS] ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue\n[PASS] Async-iterating a partially consumed stream\n[PASS] Cancellation behavior when throwing inside loop body; preventCancel = false\n[PASS] Cancellation behavior when throwing inside loop body; preventCancel = true\n[PASS] Underlying source: throwing pull method (initial pull)\n[PASS] Cancellation behavior when breaking inside loop body; preventCancel = false\n[PASS] Cancellation behavior when breaking inside loop body; preventCancel = true\n[PASS] Cancellation behavior when returning inside loop body; preventCancel = false\n[PASS] Cancellation behavior when returning inside loop body; preventCancel = true\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, enqueue()\n[PASS] Cancellation behavior when manually calling return(); preventCancel = false\n[PASS] Cancellation behavior when manually calling return(); preventCancel = true\n[PASS] Underlying source pull: throwing getter (second pull does not result in a second get)\n[PASS] next() rejects if the stream errors\n[PASS] return() does not rejects if the stream has not errored yet\n[PASS] Underlying source pull: throwing method (second pull)\n[PASS] Underlying source cancel: throwing method\n[PASS] Underlying source: calling enqueue on an empty canceled stream should throw\n[PASS] ReadableStream teeing with byte source: should not pull when original is already errored\n[PASS] Underlying source: calling enqueue on a non-empty canceled stream should throw\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, respond()\n[PASS] Underlying source: calling enqueue on a closed stream should throw\n[PASS] Underlying source: calling enqueue on an errored stream should throw\n[PASS] Underlying source: calling close twice on an empty stream should throw the second time\n[PASS] return() rejects if the stream has errored\n[PASS] next() that succeeds; next() that reports an error; next()\n[PASS] Underlying source: calling close twice on a non-empty stream should throw the second time\n[PASS] next() that succeeds; next() that reports an error(); next() [no awaiting]\n[PASS] Underlying source: calling close on an empty canceled stream should throw\n[PASS] next() that succeeds; next() that reports an error(); return()\n[PASS] Underlying source: calling close on a non-empty canceled stream should throw\n[PASS] next() that succeeds; next() that reports an error(); return() [no awaiting]\n[PASS] next() that succeeds; return()\n[PASS] Underlying source: calling close after error should throw\n[PASS] next() that succeeds; return() [no awaiting]\n[PASS] Underlying source: calling error twice should not throw\n[PASS] Underlying source: calling error after close should not throw\n[PASS] return(); next()\n[PASS] return(); next() [no awaiting]\n[PASS] Underlying source: calling error and returning a rejected promise from start should cause the stream to error with the first error\n[PASS] return(); return()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, enqueue()\n[PASS] Underlying source: calling error and returning a rejected promise from pull should cause the stream to error with the first error\n[PASS] return(); return() [no awaiting]\n[PASS] Acquiring a reader after exhaustively async-iterating a stream\n[PASS] read should not error if it dequeues and pull() throws\n[PASS] Acquiring a reader after return()ing from a stream that errors\n[PASS] Acquiring a reader after partially async-iterating a stream\n[PASS] Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true\n[PASS] ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read(view) on second reader with 1 element Uint16Array, respond(1)\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading\n[PASS] close() while next() is pending\n[PASS] ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read() on second reader, enqueue()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, read(), respondWithNewView()\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading\n[PASS] ReadableStream cancellation: cancel(reason) should pass through the given reason to the underlying source\n[PASS] ReadableStream teeing with byte source: canceling both branches in sequence with delay\n[PASS] ReadableStream teeing with byte source: failing to cancel when canceling both branches in sequence with delay\n[PASS] ReadableStream cancellation: integration test on an infinite stream derived from a random push source\n[PASS] ReadableStream cancellation: cancel() on a locked stream should fail and not call the underlying source cancel\n[PASS] ReadableStream cancellation: should fulfill promise when cancel callback went fine\n[PASS] ReadableStream cancellation: returning a value from the underlying source's cancel should not affect the fulfillment value of the promise returned by the stream's cancel\n[PASS] ReadableStream cancellation: should reject promise when cancel callback raises an exception\n[PASS] underlyingSource argument should be converted after queuingStrategy argument\n[PASS] ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (1)\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, cancel branch2\n[PASS] ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (2)\n[PASS] ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should reject when that one does\n[PASS] ReadableStream cancellation: cancelling before start finishes should prevent pull() from being called\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, cancel branch1\n[PASS] Can construct a readable stream with a valid CountQueuingStrategy\n[PASS] Correctly governs a ReadableStreamController's desiredSize property (HWM = 0)\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, enqueue to branch1\n[PASS] Correctly governs a ReadableStreamController's desiredSize property (HWM = 1)\n[PASS] Correctly governs a ReadableStreamController's desiredSize property (HWM = 4)\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, respond to branch2\n[PASS] ReadableStream teeing with byte source: pull with BYOB reader, then pull with default reader\n[PASS] ReadableStream teeing with byte source: pull with default reader, then pull with BYOB reader\n[PASS] Floating point arithmetic must manifest near NUMBER.MAX_SAFE_INTEGER (total ends up positive)\n[PASS] Floating point arithmetic must manifest near 0 (total ends up positive, but clamped)\n[PASS] Floating point arithmetic must manifest near 0 (total ends up positive, and not clamped)\n[PASS] ReadableStream.from throws on invalid iterables; specifically null\n[PASS] ReadableStream.from throws on invalid iterables; specifically undefined\n[PASS] ReadableStream.from throws on invalid iterables; specifically 0\n[PASS] Floating point arithmetic must manifest near 0 (total ends up zero)\n[PASS] ReadableStream.from throws on invalid iterables; specifically NaN\n[PASS] ReadableStream.from throws on invalid iterables; specifically true\n[PASS] ReadableStream.from throws on invalid iterables; specifically {}\n[PASS] ReadableStream.from throws on invalid iterables; specifically Object.create(null)\n[PASS] ReadableStream.from throws on invalid iterables; specifically a function\n[PASS] ReadableStream.from throws on invalid iterables; specifically a symbol\n[PASS] ReadableStream teeing with byte source: read from branch2, then read from branch1\n[PASS] ReadableStream.from throws on invalid iterables; specifically an object with a non-callable @@iterator method\n[PASS] ReadableStream.from throws on invalid iterables; specifically an object with a non-callable @@asyncIterator method\n[PASS] ReadableStream.from re-throws errors from calling the @@iterator method\n[PASS] ReadableStream.from re-throws errors from calling the @@asyncIterator method\n[PASS] ReadableStream.from ignores @@iterator if @@asyncIterator exists\n[PASS] ReadableStreamDefaultReader constructor should get a ReadableStream object as argument\n[PASS] ReadableStreamDefaultReader closed should always return the same promise object\n[PASS] Constructing a ReadableStreamDefaultReader directly should fail if the stream is already locked (via direct construction)\n[PASS] Getting a ReadableStreamDefaultReader via getReader should fail if the stream is already locked (via direct construction)\n[PASS] ReadableStream.from accepts an array of values\n[PASS] Constructing a ReadableStreamDefaultReader directly should fail if the stream is already locked (via getReader)\n[PASS] ReadableStream.from accepts an array of promises\n[PASS] Getting a ReadableStreamDefaultReader via getReader should fail if the stream is already locked (via getReader)\n[PASS] ReadableStream.from accepts an array iterator\n[PASS] ReadableStream.from accepts a string\n[PASS] Constructing a ReadableStreamDefaultReader directly should be OK if the stream is closed\n[PASS] ReadableStream.from accepts a Set\n[PASS] ReadableStream.from accepts a Set iterator\n[PASS] ReadableStream.from accepts a sync generator\n[PASS] Constructing a ReadableStreamDefaultReader directly should be OK if the stream is errored\n[PASS] ReadableStream.from accepts an async generator\n[PASS] ReadableStream teeing with byte source: read from branch1 with default reader, then close while branch2 has pending BYOB read\n[PASS] ReadableStream.from accepts a sync iterable of values\n[PASS] ReadableStream.from accepts a sync iterable of promises\n[PASS] ReadableStream.from accepts an async iterable\n[PASS] getReader() should call ToString() on mode\n[PASS] ReadableStream.from accepts a ReadableStream\n[PASS] ReadableStream.from accepts a ReadableStream async iterator\n[PASS] ReadableStream.from accepts an empty iterable"},"time":2885.03,"fullname":"wpt/test-streams","closingTestPoint":false}},{"testName":"parallel/test-runner-watch-mode","timestamp":1705971566279,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 3,win11-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=3,nodes=win11-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-azure_msft-win11_vs2022-x64-2","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":{"ok":false,"name":"parallel/test-runner-watch-mode","id":749,"buffered":false,"tapError":null,"skip":false,"todo":": Fix flaky test","previous":null,"plan":null,"diag":{"severity":"flaky","exitcode":1,"stack":"TAP version 13\n# Subtest: test runner watch mode\n    # Subtest: should run tests repeatedly\n    ok 1 - should run tests repeatedly\n      ---\n      duration_ms: 4501.7147\n      ...\n    # Subtest: should run tests with dependency repeatedly\n    ok 2 - should run tests with dependency repeatedly\n      ---\n      duration_ms: 1488.4926\n      ...\n    # Subtest: should run tests with ESM dependency\n    ok 3 - should run tests with ESM dependency\n      ---\n      duration_ms: 1544.3378\n      ...\n    # Subtest: should support running tests without a file\n    ok 4 - should support running tests without a file\n      ---\n      duration_ms: 1572.0954\n      ...\n    1..4\nok 1 - test runner watch mode\n  ---\n  duration_ms: 9110.4363\n  type: 'suite'\n  ...\n1..1\n# tests 4\n# suites 1\n# pass 4\n# fail 0\n# cancelled 0\n# skipped 0\n# todo 0\n# duration_ms 9138.4648\nCan't clean tmpdir: c:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\.tmp.656\nFiles blocking: [ 'dependency.js', 'dependency.mjs', 'test.js' ]\n\nc:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:69\n    throw e;\n    ^\n\nError: EBUSY: resource busy or locked, rmdir 'c:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\.tmp.656'\n    at rmdirSync (node:fs:1216:11)\n    at _rmdirSync (node:internal/fs/rimraf:235:5)\n    at rimrafSync (node:internal/fs/rimraf:193:7)\n    at Object.rmSync (node:fs:1265:10)\n    at rmSync (c:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:20:8)\n    at onexit (c:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:54:5)\n    at process.<anonymous> (c:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:43:14)\n    at process.emit (node:events:531:35) {\n  errno: -4082,\n  code: 'EBUSY',\n  syscall: 'rmdir',\n  path: 'c:\\\\workspace\\\\node-test-binary-windows-js-suites\\\\node\\\\test\\\\.tmp.656'\n}\n\nNode.js v22.0.0-pre"},"time":9851.138,"fullname":"parallel/test-runner-watch-mode","closingTestPoint":false}},{"testName":"sequential/test-http2-large-file","timestamp":1705971566279,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 2,win11-COMPILED_BY-vs2022 #25535","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=2,nodes=win11-COMPILED_BY-vs2022/25535/","buildNumber":25535,"builtOn":"test-azure_msft-win11_vs2022-x64-1","nodeVersion":"22.0.0","commitHash":"0530d580a6f24bd28afb77436bf26ec8c016932b","callStack":[{"upstreamBuild":60405,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":68066,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":56889,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"51526"}],"tap":{"ok":false,"name":"sequential/test-http2-large-file","id":950,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":1,"stack":"timeout"},"time":120182.006,"fullname":"sequential/test-http2-large-file","closingTestPoint":false}}]}