{"failedTests":[{"testName":"wpt/test-streams","timestamp":1718215939331,"status":"REGRESSION","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites Â» 1,win2022-COMPILED_BY-vs2022 #28159","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=1,nodes=win2022-COMPILED_BY-vs2022/28159/","buildNumber":28159,"builtOn":"test-rackspace-win2022_vs2022-x64-4","nodeVersion":"23.0.0","commitHash":"f85ab151629ec9ee1af69d93609250dd82957046","callStack":[{"upstreamBuild":63547,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":71449,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":59740,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"53418"}],"tap":{"ok":false,"name":"wpt/test-streams","id":993,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"crashed","exitcode":3221225477,"stack":"[SKIPPED] idlharness-shadowrealm.window.js: ShadowRealm support is not enabled\n[SKIPPED] queuing-strategies-size-function-per-global.window.js: Browser-specific test\n[SKIPPED] readable-streams\\cross-realm-crash.window.js: Browser-specific test\n[SKIPPED] readable-streams\\owning-type-video-frame.any.js: Browser-specific test\n[SKIPPED] readable-streams\\read-task-handling.window.js: Browser-specific test\n[SKIPPED] transferable\\deserialize-error.window.js: Browser-specific test\n[SKIPPED] transferable\\transfer-with-messageport.window.js: Browser-specific test\n[SKIPPED] transform-streams\\invalid-realm.tentative.window.js: Browser-specific test\n[PASS] a signal argument 'null' should cause pipeTo() to reject\n[PASS] a signal argument 'AbortSignal' should cause pipeTo() to reject\n[PASS] a signal argument 'true' should cause pipeTo() to reject\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; fulfilled cancel promise\n[PASS] a signal argument '-1' should cause pipeTo() to reject\n[PASS] a signal argument '[object AbortSignal]' should cause pipeTo() to reject\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; rejected cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] an aborted signal should cause the writable stream to reject with an AbortError\n[PASS] Closing must be propagated backward: starts closed; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: starts errored; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; fulfilled close promise\n[PASS] (reason: 'null') all the error objects should be the same object\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true (truthy)\n[PASS] (reason: 'undefined') all the error objects should be the same object\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = a (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 1 (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = Symbol() (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = [object Object] (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true\n[PASS] (reason: 'error1: error1') all the error objects should be the same object\n[PASS] preventCancel should prevent canceling the readable\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = undefined (falsy); fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] preventAbort should prevent aborting the readable\n[PASS] Closing must be propagated forward: starts closed; preventClose = null (falsy); fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = false (falsy); fulfilled close promise\n[PASS] preventCancel and preventAbort should prevent canceling the readable and aborting the readable\n[PASS] Closing must be propagated forward: starts closed; preventClose = 0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = -0 (falsy); fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = NaN (falsy); fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose =  (falsy); fulfilled close promise\n[PASS] (reason: 'null') abort should prevent further reads\n[PASS] Closing must be propagated forward: starts closed; preventClose = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = a (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 1 (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = Symbol() (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = [object Object] (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write, preventCancel = true; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = a (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = 1 (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = Symbol() (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = [object Object] (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true, preventCancel = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose = true\n[PASS] (reason: 'undefined') abort should prevent further reads\n[PASS] (reason: 'error1: error1') abort should prevent further reads\n[PASS] (reason: 'null') all pending writes should complete on abort\n[PASS] (reason: 'undefined') all pending writes should complete on abort\n[PASS] (reason: 'error1: error1') all pending writes should complete on abort\n[PASS] a rejection from underlyingSource.cancel() should be returned by pipeTo()\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = undefined (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = null (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = -0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = NaN (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort =  (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = a (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 1 (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = Symbol() (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = [object Object] (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true, preventClose = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = true\n[PASS] a rejection from underlyingSink.abort() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()\n[PASS] abort signal takes priority over closed readable\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; fulfilled close promise\n[PASS] abort signal takes priority over errored readable\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; rejected close promise\n[PASS] abort signal takes priority over closed writable\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose = true\n[PASS] abort signal takes priority over errored writable\n[PASS] abort should do nothing after the readable is closed\n[PASS] abort should do nothing after the readable is errored\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; fulfilled abort promise\n[PASS] abort should do nothing after the readable is errored, even with pending writes\n[PASS] abort should do nothing after the writable is errored\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; fulfilled cancel promise\n[PASS] pipeTo on a teed readable byte stream should only be aborted when both branches are aborted\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; rejected cancel promise\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = true\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; rejected close promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel omitted (but cancel is never called)\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel = true\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks, but then does\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose = true\n[PASS] Piping from an empty ReadableStream into a WritableStream that does not desire chunks, but then the readable stream becomes non-empty and the writable stream starts desiring chunks\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; fulfilled cancel promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Piping from a ReadableStream to a WritableStream that desires more chunks before finishing with previous ones\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = true\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel = true\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write\n[PASS] Errors must be propagated backward: erroring via the controller errors once pending write completes\n[PASS] idl_test validation\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write; preventClose = true\n[PASS] Closing must be propagated forward: erroring the writable while flushing pending writes should error pipeTo\n[PASS] ReadableStreamDefaultReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStreamBYOBReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStream interface: existence and properties of interface object\n[PASS] ReadableStream interface object length\n[PASS] ReadableStream interface object name\n[PASS] ReadableStream interface: existence and properties of interface prototype object\n[PASS] ReadableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; rejected abort promise\n[PASS] ReadableStream interface: operation from(any)\n[PASS] ReadableStream interface: operation getReader(optional ReadableStreamGetReaderOptions)\n[PASS] ReadableStream interface: operation pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\n[PASS] ReadableStream interface: operation tee()\n[PASS] ReadableStream interface: async iterable<any>\n[PASS] ReadableStream must be primary interface of new ReadableStream()\n[PASS] Stringification of new ReadableStream()\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"from(any)\" with the proper type\n[PASS] ReadableStream interface: calling from(any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"locked\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStream interface: calling cancel(optional any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"getReader(optional ReadableStreamGetReaderOptions)\" with the proper type\n[PASS] ReadableStream interface: calling getReader(optional ReadableStreamGetReaderOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: calling pipeThrough(ReadableWritablePair, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeTo(WritableStream, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"tee()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultReader interface object length\n[PASS] ReadableStreamDefaultReader interface object name\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultReader interface: operation releaseLock()\n[PASS] ReadableStreamDefaultReader must be primary interface of (new ReadableStream()).getReader()\n[PASS] Stringification of (new ReadableStream()).getReader()\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"read()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: calling cancel(optional any) on (new ReadableStream()).getReader() with too few arguments must throw TypeError\n[PASS] Piping to a WritableStream that does not consume the writes fast enough exerts backpressure on the ReadableStream\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBReader interface object length\n[PASS] ReadableStreamBYOBReader interface object name\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBReader interface: operation releaseLock()\n[PASS] ReadableStreamBYOBReader must be primary interface of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] Stringification of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"read(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: calling cancel(optional any) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultController interface object length\n[PASS] ReadableStreamDefaultController interface object name\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = true\n[PASS] ReadableStreamDefaultController interface: operation close()\n[PASS] ReadableStreamDefaultController interface: operation enqueue(optional any)\n[PASS] ReadableStreamDefaultController interface: operation error(optional any)\n[PASS] ReadableStreamDefaultController must be primary interface of self.readableStreamDefaultController\n[PASS] Stringification of self.readableStreamDefaultController\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"close()\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling enqueue(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling error(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: existence and properties of interface object\n[PASS] ReadableByteStreamController interface object length\n[PASS] ReadableByteStreamController interface object name\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableByteStreamController interface: operation close()\n[PASS] ReadableByteStreamController interface: operation enqueue(ArrayBufferView)\n[PASS] ReadableByteStreamController interface: operation error(optional any)\n[PASS] ReadableByteStreamController must be primary interface of self.readableByteStreamController\n[PASS] Stringification of self.readableByteStreamController\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"byobRequest\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"close()\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"enqueue(ArrayBufferView)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling enqueue(ArrayBufferView) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling error(optional any) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBRequest interface object length\n[PASS] ReadableStreamBYOBRequest interface object name\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBRequest interface: operation respond(unsigned long long)\n[PASS] ReadableStreamBYOBRequest interface: operation respondWithNewView(ArrayBufferView)\n[PASS] ReadableStreamBYOBRequest must be primary interface of self.readableStreamByobRequest\n[PASS] Stringification of self.readableStreamByobRequest\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"view\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respond(unsigned long long)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respond(unsigned long long) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respondWithNewView(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respondWithNewView(ArrayBufferView) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] WritableStream interface: existence and properties of interface object\n[PASS] WritableStream interface object length\n[PASS] WritableStream interface object name\n[PASS] WritableStream interface: existence and properties of interface prototype object\n[PASS] WritableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStream interface: operation getWriter()\n[PASS] WritableStream must be primary interface of new WritableStream()\n[PASS] Stringification of new WritableStream()\n[PASS] WritableStream interface: new WritableStream() must inherit property \"locked\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStream interface: calling abort(optional any) on new WritableStream() with too few arguments must throw TypeError\n[PASS] WritableStream interface: new WritableStream() must inherit property \"close()\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"getWriter()\" with the proper type\n[EXPECTED_FAILURE][FAIL] enqueue() must not synchronously call write algorithm\nassert_false: write algorithm must not run synchronously expected false got true\n    at Test.<anonymous> (C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\fixtures\\wpt\\streams\\piping\\general-addition.any.js:14:3)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'piping\\general-addition.any.js'\n\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface object\n[PASS] WritableStreamDefaultWriter interface object length\n[PASS] WritableStreamDefaultWriter interface object name\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStreamDefaultWriter interface: operation releaseLock()\n[PASS] WritableStreamDefaultWriter must be primary interface of (new WritableStream()).getWriter()\n[PASS] Stringification of (new WritableStream()).getWriter()\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"closed\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"desiredSize\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"ready\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling abort(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"close()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"releaseLock()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"write(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling write(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultController interface: existence and properties of interface object\n[PASS] WritableStreamDefaultController interface object length\n[PASS] WritableStreamDefaultController interface object name\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStreamDefaultController interface: operation error(optional any)\n[PASS] WritableStreamDefaultController must be primary interface of self.writableStreamDefaultController\n[PASS] Stringification of self.writableStreamDefaultController\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"signal\" with the proper type\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] WritableStreamDefaultController interface: calling error(optional any) on self.writableStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStream interface: existence and properties of interface object\n[PASS] TransformStream interface object length\n[PASS] TransformStream interface object name\n[PASS] TransformStream interface: existence and properties of interface prototype object\n[PASS] TransformStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStream must be primary interface of new TransformStream()\n[PASS] Stringification of new TransformStream()\n[PASS] TransformStream interface: new TransformStream() must inherit property \"readable\" with the proper type\n[PASS] TransformStream interface: new TransformStream() must inherit property \"writable\" with the proper type\n[PASS] TransformStreamDefaultController interface: existence and properties of interface object\n[PASS] TransformStreamDefaultController interface object length\n[PASS] TransformStreamDefaultController interface object name\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStreamDefaultController interface: operation enqueue(optional any)\n[PASS] TransformStreamDefaultController interface: operation error(optional any)\n[PASS] TransformStreamDefaultController interface: operation terminate()\n[PASS] TransformStreamDefaultController must be primary interface of self.transformStreamDefaultController\n[PASS] Stringification of self.transformStreamDefaultController\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling enqueue(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling error(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"terminate()\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface object\n[PASS] ByteLengthQueuingStrategy interface object length\n[PASS] ByteLengthQueuingStrategy interface object name\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] ByteLengthQueuingStrategy must be primary interface of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] CountQueuingStrategy interface: existence and properties of interface object\n[PASS] CountQueuingStrategy interface object length\n[PASS] CountQueuingStrategy interface object name\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] CountQueuingStrategy must be primary interface of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] ReadableStream interface: attribute locked\n[PASS] ReadableStreamDefaultController interface: attribute desiredSize\n[PASS] ReadableByteStreamController interface: attribute byobRequest\n[PASS] ReadableByteStreamController interface: attribute desiredSize\n[PASS] ReadableStreamBYOBRequest interface: attribute view\n[PASS] WritableStream interface: attribute locked\n[PASS] WritableStreamDefaultWriter interface: attribute desiredSize\n[PASS] WritableStreamDefaultController interface: attribute signal\n[PASS] TransformStream interface: attribute readable\n[PASS] TransformStream interface: attribute writable\n[PASS] TransformStreamDefaultController interface: attribute desiredSize\n[PASS] ByteLengthQueuingStrategy interface: attribute highWaterMark\n[PASS] ByteLengthQueuingStrategy interface: attribute size\n[PASS] CountQueuingStrategy interface: attribute highWaterMark\n[PASS] CountQueuingStrategy interface: attribute size\n[PASS] idl_test setup\n[PASS] ReadableStream interface: operation cancel(optional any)\n[PASS] ReadableStream interface: operation pipeTo(WritableStream, optional StreamPipeOptions)\n[PASS] ReadableStream interface: calling pipeTo(WritableStream, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultReader interface: operation read()\n[PASS] ReadableStreamDefaultReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: operation read(ArrayBufferView)\n[PASS] ReadableStreamBYOBReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: calling read(ArrayBufferView) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] WritableStream interface: operation abort(optional any)\n[PASS] WritableStream interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation abort(optional any)\n[PASS] WritableStreamDefaultWriter interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation write(optional any)\n[PASS] ReadableStreamDefaultReader interface: attribute closed\n[PASS] ReadableStreamBYOBReader interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute ready\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Piping must lock both the ReadableStream and WritableStream\n[PASS] Piping finishing must unlock both the ReadableStream and WritableStream\n[PASS] pipeTo must check the brand of its ReadableStream this value\n[PASS] pipeTo must check the brand of its WritableStream argument\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = true\n[PASS] pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream\n[PASS] pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream\n[PASS] Piping from a ReadableStream from which lots of chunks are synchronously readable\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; preventAbort = true\n[PASS] Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is true\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is false\n[PASS] pipeTo() should reject if an option getter grabs a writer\n[PASS] pipeTo() promise should resolve if null is passed\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write\n[PASS] Piping from an errored readable stream to an erroring writable stream\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write; preventAbort = true\n[PASS] Piping from an errored readable stream to an errored writable stream\n[PASS] pipeThrough should not call pipeTo on this\n[PASS] pipeThrough should not call pipeTo on the ReadableStream prototype\n[PASS] pipeThrough should brand-check this and not allow 'null'\n[PASS] pipeThrough should brand-check readable and not allow 'null'\n[PASS] Piping from an errored readable stream to an erroring writable stream; preventAbort = true\n[PASS] pipeThrough should brand-check this and not allow 'undefined'\n[PASS] pipeThrough should brand-check readable and not allow 'undefined'\n[PASS] pipeThrough should brand-check this and not allow '0'\n[PASS] pipeThrough should brand-check readable and not allow '0'\n[PASS] Piping from an errored readable stream to an errored writable stream; preventAbort = true\n[PASS] Piping from an errored readable stream to a closing writable stream\n[PASS] pipeThrough should brand-check this and not allow 'NaN'\n[PASS] pipeThrough should brand-check readable and not allow 'NaN'\n[PASS] pipeThrough should brand-check this and not allow 'true'\n[PASS] pipeThrough should brand-check readable and not allow 'true'\n[PASS] pipeThrough should brand-check this and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check readable and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check this and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check readable and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check writable and not allow 'null'\n[PASS] pipeThrough should brand-check writable and not allow 'undefined'\n[PASS] pipeThrough should brand-check writable and not allow '0'\n[PASS] pipeThrough should brand-check writable and not allow 'NaN'\n[PASS] pipeThrough should brand-check writable and not allow 'true'\n[PASS] pipeThrough should brand-check writable and not allow 'WritableStream'\n[PASS] pipeThrough should brand-check writable and not allow '[object WritableStream]'\n[PASS] pipeThrough should rethrow errors from accessing readable or writable\n[PASS] invalid values of signal should throw; specifically 'null'\n[PASS] invalid values of signal should throw; specifically '0'\n[PASS] invalid values of signal should throw; specifically 'NaN'\n[PASS] invalid values of signal should throw; specifically 'true'\n[PASS] invalid values of signal should throw; specifically 'AbortSignal'\n[PASS] invalid values of signal should throw; specifically '[object AbortSignal]'\n[PASS] pipeThrough should accept a real AbortSignal\n[PASS] pipeThrough should throw if this is locked\n[PASS] pipeThrough should throw if writable is locked\n[PASS] pipeThrough should not care if readable is locked\n[PASS] pipeThrough() should throw if an option getter grabs a writer\n[PASS] pipeThrough() should not throw if option is null\n[PASS] Piping from an errored readable stream to a closed writable stream\n[PASS] pipeThrough() should not throw if signal is undefined\n[PASS] pipeThrough() should throw if readable/writable getters throw\n[PASS] Piping from a closed readable stream to an erroring writable stream\n[PASS] Piping from a closed readable stream to an errored writable stream\n[PASS] Piping from a closed readable stream to a closed writable stream\n[PASS] Piping through a duck-typed pass-through transform stream should work\n[PASS] piping should not be observable\n[PASS] Piping through a transform errored on the writable end does not cause an unhandled promise rejection\n[PASS] tee should not be observable"},"time":2389.04,"fullname":"wpt/test-streams","closingTestPoint":false}}]}