{"failedTests":[{"testName":"wpt/test-streams","timestamp":1714153947802,"status":"REGRESSION","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites Â» 2,win2019-COMPILED_BY-vs2022 #27418","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=2,nodes=win2019-COMPILED_BY-vs2022/27418/","buildNumber":27418,"builtOn":"test-rackspace-win2019_vs2019-x64-4","nodeVersion":"23.0.0","commitHash":"c5107f2f7f573e71e1779cb438bcb0f1148ece09","callStack":[{"upstreamBuild":62518,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":70263,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":58724,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"52708"}],"tap":{"ok":false,"name":"wpt/test-streams","id":990,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"crashed","exitcode":3221225477,"stack":"[SKIPPED] idlharness-shadowrealm.window.js: ShadowRealm support is not enabled\n[SKIPPED] queuing-strategies-size-function-per-global.window.js: Browser-specific test\n[SKIPPED] readable-streams\\cross-realm-crash.window.js: Browser-specific test\n[SKIPPED] readable-streams\\owning-type-video-frame.any.js: Browser-specific test\n[SKIPPED] readable-streams\\read-task-handling.window.js: Browser-specific test\n[SKIPPED] transferable\\deserialize-error.window.js: Browser-specific test\n[SKIPPED] transferable\\transfer-with-messageport.window.js: Browser-specific test\n[SKIPPED] transform-streams\\invalid-realm.tentative.window.js: Browser-specific test\n[PASS] a signal argument 'null' should cause pipeTo() to reject\n[PASS] a signal argument 'AbortSignal' should cause pipeTo() to reject\n[PASS] a signal argument 'true' should cause pipeTo() to reject\n[PASS] a signal argument '-1' should cause pipeTo() to reject\n[PASS] a signal argument '[object AbortSignal]' should cause pipeTo() to reject\n[PASS] an aborted signal should cause the writable stream to reject with an AbortError\n[PASS] (reason: 'null') all the error objects should be the same object\n[PASS] (reason: 'undefined') all the error objects should be the same object\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; rejected cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] (reason: 'error1: error1') all the error objects should be the same object\n[PASS] preventCancel should prevent canceling the readable\n[PASS] preventAbort should prevent aborting the readable\n[PASS] preventCancel and preventAbort should prevent canceling the readable and aborting the readable\n[PASS] (reason: 'null') abort should prevent further reads\n[PASS] Errors must be propagated backward: starts errored; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = undefined (falsy); fulfilled close promise\n[PASS] (reason: 'undefined') abort should prevent further reads\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] (reason: 'error1: error1') abort should prevent further reads\n[PASS] Closing must be propagated forward: starts closed; preventClose = null (falsy); fulfilled close promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = false (falsy); fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = 0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = -0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = NaN (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose =  (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = true (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = a (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = 1 (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = Symbol() (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = [object Object] (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = a (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 1 (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = Symbol() (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = [object Object] (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write, preventCancel = true; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = a (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 1 (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = Symbol() (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = [object Object] (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] (reason: 'null') all pending writes should complete on abort\n[PASS] (reason: 'undefined') all pending writes should complete on abort\n[PASS] (reason: 'error1: error1') all pending writes should complete on abort\n[PASS] a rejection from underlyingSource.cancel() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()\n[PASS] abort signal takes priority over closed readable\n[PASS] abort signal takes priority over errored readable\n[PASS] abort signal takes priority over closed writable\n[PASS] abort signal takes priority over errored writable\n[PASS] abort should do nothing after the readable is closed\n[PASS] abort should do nothing after the readable is errored\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = undefined (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = null (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = -0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = NaN (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort =  (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = a (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 1 (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = Symbol() (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = [object Object] (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true, preventClose = true\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks, but then does\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = true\n[PASS] abort should do nothing after the readable is errored, even with pending writes\n[PASS] abort should do nothing after the writable is errored\n[PASS] Piping from an empty ReadableStream into a WritableStream that does not desire chunks, but then the readable stream becomes non-empty and the writable stream starts desiring chunks\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; fulfilled abort promise\n[PASS] pipeTo on a teed readable byte stream should only be aborted when both branches are aborted\n[PASS] Piping from a ReadableStream to a WritableStream that desires more chunks before finishing with previous ones\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; rejected cancel promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; rejected close promise\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel omitted (but cancel is never called)\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel = true\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose = true\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel = true\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write\n[PASS] Piping to a WritableStream that does not consume the writes fast enough exerts backpressure on the ReadableStream\n[PASS] Errors must be propagated backward: erroring via the controller errors once pending write completes\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write; preventClose = true\n[PASS] Closing must be propagated forward: erroring the writable while flushing pending writes should error pipeTo\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; rejected abort promise\n[PASS] idl_test validation\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = true\n[PASS] ReadableStreamDefaultReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStreamBYOBReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStream interface: existence and properties of interface object\n[PASS] ReadableStream interface object length\n[PASS] ReadableStream interface object name\n[PASS] ReadableStream interface: existence and properties of interface prototype object\n[PASS] ReadableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[EXPECTED_FAILURE][FAIL] enqueue() must not synchronously call write algorithm\nassert_false: write algorithm must not run synchronously expected false got true\n    at Test.<anonymous> (C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\fixtures\\wpt\\streams\\piping\\general-addition.any.js:14:3)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'piping\\general-addition.any.js'\n\n[PASS] ReadableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStream interface: operation from(any)\n[PASS] ReadableStream interface: operation getReader(optional ReadableStreamGetReaderOptions)\n[PASS] ReadableStream interface: operation pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] ReadableStream interface: operation tee()\n[PASS] ReadableStream interface: async iterable<any>\n[PASS] ReadableStream must be primary interface of new ReadableStream()\n[PASS] Stringification of new ReadableStream()\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"from(any)\" with the proper type\n[PASS] ReadableStream interface: calling from(any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"locked\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStream interface: calling cancel(optional any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"getReader(optional ReadableStreamGetReaderOptions)\" with the proper type\n[PASS] ReadableStream interface: calling getReader(optional ReadableStreamGetReaderOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: calling pipeThrough(ReadableWritablePair, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeTo(WritableStream, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"tee()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultReader interface object length\n[PASS] ReadableStreamDefaultReader interface object name\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultReader interface: operation releaseLock()\n[PASS] ReadableStreamDefaultReader must be primary interface of (new ReadableStream()).getReader()\n[PASS] Stringification of (new ReadableStream()).getReader()\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"read()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: calling cancel(optional any) on (new ReadableStream()).getReader() with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBReader interface object length\n[PASS] ReadableStreamBYOBReader interface object name\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBReader interface: operation releaseLock()\n[PASS] ReadableStreamBYOBReader must be primary interface of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] Stringification of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"read(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: calling cancel(optional any) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultController interface object length\n[PASS] ReadableStreamDefaultController interface object name\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultController interface: operation close()\n[PASS] ReadableStreamDefaultController interface: operation enqueue(optional any)\n[PASS] ReadableStreamDefaultController interface: operation error(optional any)\n[PASS] ReadableStreamDefaultController must be primary interface of self.readableStreamDefaultController\n[PASS] Stringification of self.readableStreamDefaultController\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"close()\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling enqueue(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling error(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] ReadableByteStreamController interface: existence and properties of interface object\n[PASS] ReadableByteStreamController interface object length\n[PASS] ReadableByteStreamController interface object name\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableByteStreamController interface: operation close()\n[PASS] ReadableByteStreamController interface: operation enqueue(ArrayBufferView)\n[PASS] ReadableByteStreamController interface: operation error(optional any)\n[PASS] ReadableByteStreamController must be primary interface of self.readableByteStreamController\n[PASS] Stringification of self.readableByteStreamController\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"byobRequest\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"close()\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"enqueue(ArrayBufferView)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling enqueue(ArrayBufferView) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling error(optional any) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBRequest interface object length\n[PASS] ReadableStreamBYOBRequest interface object name\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBRequest interface: operation respond(unsigned long long)\n[PASS] ReadableStreamBYOBRequest interface: operation respondWithNewView(ArrayBufferView)\n[PASS] ReadableStreamBYOBRequest must be primary interface of self.readableStreamByobRequest\n[PASS] Stringification of self.readableStreamByobRequest\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"view\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respond(unsigned long long)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respond(unsigned long long) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respondWithNewView(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respondWithNewView(ArrayBufferView) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] WritableStream interface: existence and properties of interface object\n[PASS] WritableStream interface object length\n[PASS] WritableStream interface object name\n[PASS] WritableStream interface: existence and properties of interface prototype object\n[PASS] WritableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStream interface: operation getWriter()\n[PASS] WritableStream must be primary interface of new WritableStream()\n[PASS] Stringification of new WritableStream()\n[PASS] WritableStream interface: new WritableStream() must inherit property \"locked\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStream interface: calling abort(optional any) on new WritableStream() with too few arguments must throw TypeError\n[PASS] WritableStream interface: new WritableStream() must inherit property \"close()\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"getWriter()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface object\n[PASS] WritableStreamDefaultWriter interface object length\n[PASS] WritableStreamDefaultWriter interface object name\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = true\n[PASS] WritableStreamDefaultWriter interface: operation releaseLock()\n[PASS] WritableStreamDefaultWriter must be primary interface of (new WritableStream()).getWriter()\n[PASS] Stringification of (new WritableStream()).getWriter()\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"closed\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"desiredSize\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"ready\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling abort(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"close()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"releaseLock()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"write(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling write(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultController interface: existence and properties of interface object\n[PASS] WritableStreamDefaultController interface object length\n[PASS] WritableStreamDefaultController interface object name\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStreamDefaultController interface: operation error(optional any)\n[PASS] WritableStreamDefaultController must be primary interface of self.writableStreamDefaultController\n[PASS] Stringification of self.writableStreamDefaultController\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"signal\" with the proper type\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] WritableStreamDefaultController interface: calling error(optional any) on self.writableStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStream interface: existence and properties of interface object\n[PASS] TransformStream interface object length\n[PASS] TransformStream interface object name\n[PASS] TransformStream interface: existence and properties of interface prototype object\n[PASS] TransformStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes\n[PASS] TransformStream must be primary interface of new TransformStream()\n[PASS] Stringification of new TransformStream()\n[PASS] TransformStream interface: new TransformStream() must inherit property \"readable\" with the proper type\n[PASS] TransformStream interface: new TransformStream() must inherit property \"writable\" with the proper type\n[PASS] TransformStreamDefaultController interface: existence and properties of interface object\n[PASS] TransformStreamDefaultController interface object length\n[PASS] TransformStreamDefaultController interface object name\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStreamDefaultController interface: operation enqueue(optional any)\n[PASS] TransformStreamDefaultController interface: operation error(optional any)\n[PASS] TransformStreamDefaultController interface: operation terminate()\n[PASS] TransformStreamDefaultController must be primary interface of self.transformStreamDefaultController\n[PASS] Stringification of self.transformStreamDefaultController\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling enqueue(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling error(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"terminate()\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface object\n[PASS] ByteLengthQueuingStrategy interface object length\n[PASS] ByteLengthQueuingStrategy interface object name\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ByteLengthQueuingStrategy must be primary interface of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] CountQueuingStrategy interface: existence and properties of interface object\n[PASS] CountQueuingStrategy interface object length\n[PASS] CountQueuingStrategy interface object name\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] CountQueuingStrategy must be primary interface of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] ReadableStream interface: attribute locked\n[PASS] ReadableStreamDefaultController interface: attribute desiredSize\n[PASS] ReadableByteStreamController interface: attribute byobRequest\n[PASS] ReadableByteStreamController interface: attribute desiredSize\n[PASS] ReadableStreamBYOBRequest interface: attribute view\n[PASS] WritableStream interface: attribute locked\n[PASS] WritableStreamDefaultWriter interface: attribute desiredSize\n[PASS] WritableStreamDefaultController interface: attribute signal\n[PASS] TransformStream interface: attribute readable\n[PASS] TransformStream interface: attribute writable\n[PASS] TransformStreamDefaultController interface: attribute desiredSize\n[PASS] ByteLengthQueuingStrategy interface: attribute highWaterMark\n[PASS] ByteLengthQueuingStrategy interface: attribute size\n[PASS] CountQueuingStrategy interface: attribute highWaterMark\n[PASS] CountQueuingStrategy interface: attribute size\n[PASS] idl_test setup\n[PASS] ReadableStream interface: operation cancel(optional any)\n[PASS] ReadableStream interface: operation pipeTo(WritableStream, optional StreamPipeOptions)\n[PASS] ReadableStream interface: calling pipeTo(WritableStream, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultReader interface: operation read()\n[PASS] ReadableStreamDefaultReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: operation read(ArrayBufferView)\n[PASS] ReadableStreamBYOBReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: calling read(ArrayBufferView) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] WritableStream interface: operation abort(optional any)\n[PASS] WritableStream interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation abort(optional any)\n[PASS] WritableStreamDefaultWriter interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation write(optional any)\n[PASS] ReadableStreamDefaultReader interface: attribute closed\n[PASS] ReadableStreamBYOBReader interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute ready\n[PASS] Piping must lock both the ReadableStream and WritableStream\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; preventAbort = true\n[PASS] Piping finishing must unlock both the ReadableStream and WritableStream\n[PASS] pipeTo must check the brand of its ReadableStream this value\n[PASS] pipeTo must check the brand of its WritableStream argument\n[PASS] pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream\n[PASS] pipeThrough should not call pipeTo on this\n[PASS] pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream\n[PASS] pipeThrough should not call pipeTo on the ReadableStream prototype\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write\n[PASS] pipeThrough should brand-check this and not allow 'null'\n[PASS] Piping from an errored readable stream to an erroring writable stream\n[PASS] pipeThrough should brand-check readable and not allow 'null'\n[PASS] pipeThrough should brand-check this and not allow 'undefined'\n[PASS] pipeThrough should brand-check readable and not allow 'undefined'\n[PASS] Piping from an errored readable stream to an errored writable stream\n[PASS] Piping from an errored readable stream to an erroring writable stream; preventAbort = true\n[PASS] Piping from an errored readable stream to an errored writable stream; preventAbort = true\n[PASS] pipeThrough should brand-check this and not allow '0'\n[PASS] pipeThrough should brand-check readable and not allow '0'\n[PASS] pipeThrough should brand-check this and not allow 'NaN'\n[PASS] pipeThrough should brand-check readable and not allow 'NaN'\n[PASS] pipeThrough should brand-check this and not allow 'true'\n[PASS] pipeThrough should brand-check readable and not allow 'true'\n[PASS] pipeThrough should brand-check this and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check readable and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check this and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check readable and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check writable and not allow 'null'\n[PASS] pipeThrough should brand-check writable and not allow 'undefined'\n[PASS] pipeThrough should brand-check writable and not allow '0'\n[PASS] pipeThrough should brand-check writable and not allow 'NaN'\n[PASS] pipeThrough should brand-check writable and not allow 'true'\n[PASS] pipeThrough should brand-check writable and not allow 'WritableStream'\n[PASS] pipeThrough should brand-check writable and not allow '[object WritableStream]'\n[PASS] pipeThrough should rethrow errors from accessing readable or writable\n[PASS] Piping from a ReadableStream from which lots of chunks are synchronously readable\n[PASS] Piping from an errored readable stream to a closing writable stream\n[PASS] invalid values of signal should throw; specifically 'null'\n[PASS] invalid values of signal should throw; specifically '0'\n[PASS] invalid values of signal should throw; specifically 'NaN'\n[PASS] invalid values of signal should throw; specifically 'true'\n[PASS] invalid values of signal should throw; specifically 'AbortSignal'\n[PASS] invalid values of signal should throw; specifically '[object AbortSignal]'\n[PASS] pipeThrough should accept a real AbortSignal\n[PASS] pipeThrough should throw if this is locked\n[PASS] pipeThrough should throw if writable is locked\n[PASS] Piping from an errored readable stream to a closed writable stream\n[PASS] pipeThrough should not care if readable is locked\n[PASS] pipeThrough() should throw if an option getter grabs a writer\n[PASS] pipeThrough() should not throw if option is null\n[PASS] pipeThrough() should not throw if signal is undefined\n[PASS] Piping from a closed readable stream to an erroring writable stream\n[PASS] pipeThrough() should throw if readable/writable getters throw\n[PASS] Piping from a closed readable stream to an errored writable stream\n[PASS] piping should not be observable\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write; preventAbort = true\n[PASS] Piping from a closed readable stream to a closed writable stream\n[PASS] tee should not be observable\n[PASS] Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false\n[PASS] Piping through a duck-typed pass-through transform stream should work\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is true\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is false\n[PASS] pipeTo() should reject if an option getter grabs a writer\n[PASS] pipeTo() promise should resolve if null is passed\n[PASS] Piping through a transform errored on the writable end does not cause an unhandled promise rejection\n[PASS] preventCancel should work\n[PASS] preventClose should work\n[PASS] preventAbort should work\n[PASS] pipeThrough should stop after getting preventAbort throws\n[PASS] pipeThrough should stop after getting preventCancel throws\n[PASS] pipeThrough should stop after getting preventClose throws\n[PASS] pipeThrough should stop after getting signal throws\n[PASS] pipeTo should stop after getting preventAbort throws\n[PASS] pipeTo should stop after getting preventCancel throws\n[PASS] pipeTo should stop after getting preventClose throws\n[PASS] pipeTo should stop after getting signal throws\n[PASS] Piping through an identity transform stream should close the destination when the source closes\n[PASS] CountQueuingStrategy: Can construct a with a valid high water mark\n[PASS] enqueue after detaching byobRequest.view.buffer should throw\n[PASS] CountQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] CountQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] CountQueuingStrategy: size is the same function across all instances\n[PASS] CountQueuingStrategy: size should have the right name\n[PASS] CountQueuingStrategy: subclassing should work correctly\n[PASS] CountQueuingStrategy: size should not have a prototype property\n[PASS] ByteLengthQueuingStrategy: Can construct a with a valid high water mark\n[PASS] ByteLengthQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] ByteLengthQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] ByteLengthQueuingStrategy: size is the same function across all instances\n[PASS] ByteLengthQueuingStrategy: size should have the right name\n[PASS] ByteLengthQueuingStrategy: subclassing should work correctly\n[PASS] ByteLengthQueuingStrategy: size should not have a prototype property\n[PASS] CountQueuingStrategy: size should not be a constructor\n[PASS] ByteLengthQueuingStrategy: size should not be a constructor\n[PASS] CountQueuingStrategy: size should have the right length\n[PASS] ByteLengthQueuingStrategy: size should have the right length\n[PASS] CountQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ReadableStream with byte source: enqueuing an already-detached buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length view on a non-zero-length buffer throws\n[PASS] ByteLengthQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the readable state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a undefined view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is zero-length on a non-zero-length buffer (in the readable state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the readable state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the readable state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a undefined view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (autoAllocateChunkSize)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a null view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a larger length (in the readable state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is non-zero-length (in the closed state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a null view\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the closed state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a fake view\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: read()ing from a closed stream still transfers the buffer\n[PASS] ReadableStream with byte source: read()ing from a stream with queued chunks still transfers the buffer\n[PASS] ReadableStream with byte source: reading into an already-detached buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length view on a non-zero-length buffer rejects\n[PASS] getReader({mode: \"byob\"}) throws on non-bytes streams\n[PASS] ReadableStream with byte source can be constructed with no errors\n[PASS] getReader({mode}) must perform ToString()\n[PASS] ReadableStream with byte source: start() throws an exception\n[PASS] ReadableStream with byte source: desiredSize when closed\n[PASS] ReadableStream with byte source: desiredSize when errored\n[PASS] ReadableStream with byte source: pull() function is not callable\n[PASS] ReadableStream with byte source: Throw if close()-ed more than once\n[PASS] ReadableStream with byte source: Throw on enqueue() after close()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize cannot be 0\n[PASS] ReadableStreamBYOBReader can be constructed directly\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream argument\n[PASS] ReadableStreamBYOBReader constructor requires an unlocked ReadableStream\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream with type \"bytes\"\n[PASS] ReadableStream with byte source: enqueue() with a non-transferable buffer\n[PASS] ReadableStream constructor should not accept a strategy with a size defined if type is \"bytes\"\n[PASS] ReadableStream with byte source: Construct and expect start and pull being called\n[PASS] ReadableStream with byte source: No automatic pull call if start doesn't finish\n[PASS] ReadableStream with byte source: Construct with highWaterMark of 0\n[PASS] ReadableStream with byte source: read() with a non-transferable buffer\n[PASS] ReadableStream with byte source: getReader(), then releaseLock()\n[PASS] ReadableStream with byte source: getReader() with mode set to byob, then releaseLock()\n[PASS] ReadableStream with byte source: fill() with a non-transferable buffer\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: respondWithNewView() with a non-transferable buffer\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: releaseLock() on ReadableStreamDefaultReader must reject pending read()\n[PASS] ReadableStream with byte source: releaseLock() on ReadableStreamBYOBReader must reject pending read()\n[PASS] ReadableStream with byte source: Automatic pull() after start()\n[PASS] ReadableStream with byte source: Automatic pull() after start() and read()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize\n[PASS] ReadableStream with byte source: Mix of auto allocate and BYOB\n[PASS] ReadableStream with byte source: Automatic pull() after start() and read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read()\n[PASS] ReadableStream with byte source: Push source that doesn't understand pull signal\n[PASS] ReadableStream with byte source: enqueue() with Uint16Array, getReader(), then read()\n[PASS] ReadableStream with byte source: enqueue(), read(view) partially, then read()\n[PASS] ReadableStream with byte source: getReader(), enqueue(), close(), then read()\n[PASS] ReadableStream with byte source: enqueue(), close(), getReader(), then read()\n[PASS] ReadableStream with byte source: Respond to pull() by enqueue()\n[PASS] ReadableStream with byte source: Respond to pull() by enqueue() asynchronously\n[PASS] ReadableStream with byte source: Respond to multiple pull() by separate enqueue()\n[PASS] ReadableStream with byte source: read(view), then respond()\n[PASS] ReadableStream with byte source: read(view), then respondWithNewView() with a transferred ArrayBuffer\n[PASS] ReadableStream with byte source: read(view), then respond() with too big value\n[PASS] ReadableStream with byte source: respond(3) to read(view) with 2 element Uint16Array enqueues the 1 byte remainder\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = not BYOB)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = BYOB)\n[PASS] ReadableStream with byte source: getReader(), read(view), then cancel()\n[PASS] ReadableStream with byte source: cancel() with partially filled pending pull() request\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) where view.buffer is not fully covered by view\n[PASS] ReadableStream with byte source: Multiple enqueue(), getReader(), then read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) with a bigger view\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) with smaller views\n[PASS] ReadableStream with byte source: enqueue() 1 byte, getReader(), then read(view) with Uint16Array\n[PASS] ReadableStream with byte source: enqueue() 3 byte, getReader(), then read(view) with 2-element Uint16Array\n[PASS] ReadableStream with byte source: read(view) with Uint16Array on close()-d stream with 1 byte enqueue()-d must fail\n[PASS] ReadableStream with byte source: A stream must be errored if close()-d before fulfilling read(view) with Uint16Array\n[PASS] ReadableStream with byte source: read(view), then respond() and close() in pull()\n[PASS] ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple respond() calls\n[PASS] ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple enqueue() calls\n[PASS] ReadableStream with byte source: read() twice, then enqueue() twice\n[PASS] ReadableStream with byte source: Multiple read(view), close() and respond()\n[PASS] ReadableStream with byte source: Multiple read(view), big enqueue()\n[PASS] ReadableStream with byte source: Multiple read(view) and multiple enqueue()\n[PASS] ReadableStream with byte source: read(view) with passing undefined as view must fail\n[PASS] ReadableStream with byte source: read(view) with passing an empty object as view must fail\n[PASS] ReadableStream with byte source: Even read(view) with passing ArrayBufferView like object as view must fail\n[PASS] ReadableStream with byte source: read() on an errored stream\n[PASS] ReadableStream with byte source: read(), then error()\n[PASS] ReadableStream with byte source: read(view) on an errored stream\n[PASS] ReadableStream with byte source: read(view), then error()\n[PASS] ReadableStream with byte source: Throwing in pull function must error the stream\n[PASS] ReadableStream with byte source: Throwing in pull in response to read() must be ignored if the stream is errored in it\n[PASS] ReadableStream with byte source: Throwing in pull in response to read(view) function must error the stream\n[PASS] ReadableStream with byte source: Throwing in pull in response to read(view) must be ignored if the stream is errored in it\n[PASS] calling respond() twice on the same byobRequest should throw\n[PASS] calling respondWithNewView() twice on the same byobRequest should throw\n[PASS] calling respond(0) twice on the same byobRequest should throw even when closed\n[PASS] calling respond() should throw when canceled\n[PASS] pull() resolving should not resolve read()\n[PASS] ReadableStream with byte source: default reader + autoAllocateChunkSize + byobRequest interaction\n[PASS] ReadableStream with byte source: respondWithNewView() with a smaller view\n[PASS] ReadableStream with byte source: respondWithNewView() with a zero-length view (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() with a transferred non-zero-length view (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() with a transferred zero-length view (in the closed state)\n[PASS] ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams\n[PASS] Running templatedRSTeeCancel with ReadableStream teeing with byte source\n[PASS] ReadableStream with byte source: enqueue() discards auto-allocated BYOB request\n[PASS] byobRequest.respond() after enqueue() should not crash\n[PASS] byobRequest.respond() with cached byobRequest after enqueue() should not crash\n[PASS] byobRequest.respond() after enqueue() with double read should not crash\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respond()\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is 0\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is negative\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint8Array)\n[PASS] ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint16Array)\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (DataView)\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 1 element Uint16Array, respond(1)\n[PASS] ReadableStream teeing with byte source: chunks should be cloned for each branch\n[PASS] ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2\n[PASS] ReadableStream teeing with byte source: errors in the source should propagate to both branches\n[PASS] ReadableStream with byte source: read({ min }), then read()\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 2 element Uint8Array, respond(3)\n[PASS] ReadableStream teeing with byte source: canceling branch1 should not impact branch2\n[PASS] ReadableStream with byte source: read({ min }) with a DataView\n[PASS] ReadableStream teeing with byte source: canceling branch2 should not impact branch1\n[PASS] ReadableStream with byte source: enqueue(), then read({ min })\n[PASS] ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array\n[PASS] ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 3-byte Uint8Array, then multiple enqueue() up to 3 bytes\n[PASS] Async iterator instances should have the correct list of properties\n[PASS] ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respondWithNewView()\n[PASS] ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches\n[PASS] values() throws if there's already a lock\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 3 bytes\n[PASS] ReadableStream teeing with byte source: closing the original should close the branches\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 4 bytes\n[PASS] ReadableStream teeing with byte source: erroring the original should immediately error the branches\n[PASS] return() should unlock the stream synchronously when preventCancel = false\n[PASS] ReadableStream teeing with byte source: erroring the original should error pending reads from default reader\n[PASS] return() should unlock the stream synchronously when preventCancel = true\n[PASS] ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader\n[PASS] Async-iterating a push source\n[PASS] ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream\n[PASS] Async-iterating a pull source\n[PASS] ReadableStream with byte source: enqueue(), read({ min }) partially, then read()\n[PASS] ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, enqueue()\n[PASS] Async-iterating a push source with undefined values\n[PASS] Async-iterating a pull source with undefined values\n[PASS] ReadableStream with byte source: read({ min }), then respondWithNewView() with a transferred ArrayBuffer\n[PASS] ReadableStream with byte source: read({ min }) on a closed stream\n[PASS] Async-iterating a pull source manually\n[PASS] ReadableStream with byte source: read({ min }) when closed before view is filled\n[PASS] ReadableStream with byte source: read({ min }) when closed immediately after view is filled\n[PASS] Async-iterating an errored stream throws\n[PASS] Async-iterating a closed stream never executes the loop body, but works fine\n[PASS] ReadableStream teeing with byte source: should not pull any chunks if no branches are reading\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, close(), respond(0)\n[PASS] ReadableStream with byte source: read({ min }) on an errored stream\n[PASS] ReadableStream with byte source: read({ min }), then error()\n[PASS] ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue\n[PASS] ReadableStream with byte source: getReader(), read({ min }), then cancel()\n[PASS] ReadableStream with byte source: cancel() with partially filled pending read({ min }) request\n[PASS] Readable stream: throwing strategy.size getter\n[PASS] Readable stream: throwing strategy.highWaterMark getter\n[PASS] ReadableStream with byte source: enqueue(), then read({ min }) with smaller views\n[PASS] Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function\n[PASS] ReadableStream with byte source: 3 byte enqueue(), then close(), then read({ min }) with 2-element Uint16Array must fail\n[PASS] Readable stream: invalid strategy.highWaterMark\n[PASS] ReadableStream with byte source: read({ min }) with 2-element Uint16Array, then 3 byte enqueue(), then close() must fail\n[PASS] Async-iterating a partially consumed stream\n[PASS] Cancellation behavior when throwing inside loop body; preventCancel = false\n[PASS] Cancellation behavior when throwing inside loop body; preventCancel = true\n[PASS] Cancellation behavior when breaking inside loop body; preventCancel = false\n[PASS] Cancellation behavior when breaking inside loop body; preventCancel = true\n[PASS] Cancellation behavior when returning inside loop body; preventCancel = false\n[PASS] Cancellation behavior when returning inside loop body; preventCancel = true\n[PASS] Readable stream: strategy.size errors the stream and then throws\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, respond()\n[PASS] Cancellation behavior when manually calling return(); preventCancel = false\n[PASS] Readable stream: strategy.size errors the stream and then returns Infinity\n[PASS] Cancellation behavior when manually calling return(); preventCancel = true\n[PASS] ReadableStream with byte source: tee() with read({ min }) from branch1 and read() from branch2\n[PASS] Readable stream: throwing strategy.size method\n[PASS] ReadableStream teeing with byte source: should not pull when original is already errored\n[PASS] next() rejects if the stream errors\n[PASS] return() does not rejects if the stream has not errored yet\n[PASS] Underlying source start: throwing getter\n[PASS] Readable stream: invalid strategy.size return value\n[PASS] Underlying source start: throwing method\n[PASS] Underlying source: throwing pull getter (initial pull)\n[PASS] Underlying source cancel: throwing getter\n[PASS] Readable stream: invalid strategy.size return value when pulling\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, enqueue()\n[PASS] return() rejects if the stream has errored\n[PASS] next() that succeeds; next() that reports an error; next()\n[PASS] next() that succeeds; next() that reports an error(); next() [no awaiting]\n[PASS] next() that succeeds; next() that reports an error(); return()\n[PASS] next() that succeeds; next() that reports an error(); return() [no awaiting]\n[PASS] next() that succeeds; return()\n[PASS] next() that succeeds; return() [no awaiting]\n[PASS] return(); next()\n[PASS] return(); next() [no awaiting]\n[PASS] return(); return()\n[PASS] return(); return() [no awaiting]\n[PASS] Acquiring a reader after exhaustively async-iterating a stream\n[PASS] Acquiring a reader after return()ing from a stream that errors\n[PASS] Acquiring a reader after partially async-iterating a stream\n[PASS] Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true\n[PASS] Underlying source: throwing pull method (initial pull)\n[PASS] Underlying source pull: throwing getter (second pull does not result in a second get)\n[PASS] Underlying source pull: throwing method (second pull)\n[PASS] Underlying source cancel: throwing method\n[PASS] Underlying source: calling enqueue on an empty canceled stream should throw\n[PASS] Underlying source: calling enqueue on a non-empty canceled stream should throw\n[PASS] Underlying source: calling enqueue on a closed stream should throw\n[PASS] Underlying source: calling enqueue on an errored stream should throw\n[PASS] Underlying source: calling close twice on an empty stream should throw the second time\n[PASS] Underlying source: calling close twice on a non-empty stream should throw the second time\n[PASS] Underlying source: calling close on an empty canceled stream should throw\n[PASS] Underlying source: calling close on a non-empty canceled stream should throw\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, respond()\n[PASS] Underlying source: calling close after error should throw\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading\n[PASS] Underlying source: calling error twice should not throw\n[PASS] close() while next() is pending\n[PASS] Underlying source: calling error after close should not throw\n[PASS] Underlying source: calling error and returning a rejected promise from start should cause the stream to error with the first error\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, enqueue()\n[PASS] Underlying source: calling error and returning a rejected promise from pull should cause the stream to error with the first error\n[PASS] read should not error if it dequeues and pull() throws\n[PASS] ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read(view) on second reader with 1 element Uint16Array, respond(1)\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading\n[PASS] ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read() on second reader, enqueue()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, read(), respondWithNewView()\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading"},"time":1276.996,"fullname":"wpt/test-streams","closingTestPoint":false}}]}