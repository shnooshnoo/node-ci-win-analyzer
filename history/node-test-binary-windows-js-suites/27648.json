{"failedTests":[{"testName":"wpt/test-streams","timestamp":1715298961755,"status":"REGRESSION","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites Â» 3,win2019-COMPILED_BY-vs2022 #27648","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=3,nodes=win2019-COMPILED_BY-vs2022/27648/","buildNumber":27648,"builtOn":"test-rackspace-win2019_vs2019-x64-3","nodeVersion":"23.0.0","commitHash":"958ef095025f07c148a564994565cc55045eb96a","callStack":[{"upstreamBuild":62853,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":70661,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":59069,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"52766"}],"tap":{"ok":false,"name":"wpt/test-streams","id":986,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":3221226356,"stack":"[SKIPPED] idlharness-shadowrealm.window.js: ShadowRealm support is not enabled\n[SKIPPED] queuing-strategies-size-function-per-global.window.js: Browser-specific test\n[SKIPPED] readable-streams\\cross-realm-crash.window.js: Browser-specific test\n[SKIPPED] readable-streams\\owning-type-video-frame.any.js: Browser-specific test\n[SKIPPED] readable-streams\\read-task-handling.window.js: Browser-specific test\n[SKIPPED] transferable\\deserialize-error.window.js: Browser-specific test\n[SKIPPED] transferable\\transfer-with-messageport.window.js: Browser-specific test\n[SKIPPED] transform-streams\\invalid-realm.tentative.window.js: Browser-specific test\n[PASS] a signal argument 'null' should cause pipeTo() to reject\n[PASS] a signal argument 'AbortSignal' should cause pipeTo() to reject\n[PASS] a signal argument 'true' should cause pipeTo() to reject\n[PASS] a signal argument '-1' should cause pipeTo() to reject\n[PASS] a signal argument '[object AbortSignal]' should cause pipeTo() to reject\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; fulfilled cancel promise\n[PASS] an aborted signal should cause the writable stream to reject with an AbortError\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; rejected cancel promise\n[PASS] (reason: 'null') all the error objects should be the same object\n[PASS] Closing must be propagated backward: starts closed; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] (reason: 'undefined') all the error objects should be the same object\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; fulfilled close promise\n[PASS] (reason: 'error1: error1') all the error objects should be the same object\n[PASS] Closing must be propagated backward: starts closed; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; rejected close promise\n[PASS] preventCancel should prevent canceling the readable\n[PASS] Closing must be propagated backward: starts closed; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] preventAbort should prevent aborting the readable\n[PASS] preventCancel and preventAbort should prevent canceling the readable and aborting the readable\n[PASS] Closing must be propagated forward: starts closed; preventClose = undefined (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = null (falsy); fulfilled close promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = false (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = 0 (falsy); fulfilled close promise\n[PASS] (reason: 'null') abort should prevent further reads\n[PASS] Errors must be propagated backward: starts errored; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = -0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = NaN (falsy); fulfilled close promise\n[PASS] (reason: 'undefined') abort should prevent further reads\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = a (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 1 (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = Symbol() (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = [object Object] (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] (reason: 'error1: error1') abort should prevent further reads\n[PASS] (reason: 'null') all pending writes should complete on abort\n[PASS] Closing must be propagated forward: starts closed; preventClose =  (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = true (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = a (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = 1 (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = Symbol() (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = [object Object] (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true, preventCancel = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; rejected close promise\n[PASS] (reason: 'undefined') all pending writes should complete on abort\n[PASS] (reason: 'error1: error1') all pending writes should complete on abort\n[PASS] a rejection from underlyingSource.cancel() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be returned by pipeTo()\n[PASS] Errors must be propagated forward: starts errored; preventAbort = undefined (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = null (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()\n[PASS] abort signal takes priority over closed readable\n[PASS] Errors must be propagated forward: starts errored; preventAbort = -0 (falsy); fulfilled abort promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose = true\n[PASS] abort signal takes priority over errored readable\n[PASS] Errors must be propagated forward: starts errored; preventAbort = NaN (falsy); fulfilled abort promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] abort signal takes priority over closed writable\n[PASS] abort signal takes priority over errored writable\n[PASS] Errors must be propagated forward: starts errored; preventAbort =  (falsy); fulfilled abort promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; rejected close promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] abort should do nothing after the readable is closed\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = a (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 1 (truthy)\n[PASS] abort should do nothing after the readable is errored\n[PASS] Errors must be propagated forward: starts errored; preventAbort = a (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 1 (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = Symbol() (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = [object Object] (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true, preventClose = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = Symbol() (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = [object Object] (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write, preventCancel = true; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose = true\n[PASS] abort should do nothing after the readable is errored, even with pending writes\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks\n[PASS] abort should do nothing after the writable is errored\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; fulfilled cancel promise\n[PASS] pipeTo on a teed readable byte stream should only be aborted when both branches are aborted\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = true\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks, but then does\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; fulfilled close promise\n[PASS] Piping from an empty ReadableStream into a WritableStream that does not desire chunks, but then the readable stream becomes non-empty and the writable stream starts desiring chunks\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; fulfilled cancel promise\n[PASS] Piping from a ReadableStream to a WritableStream that desires more chunks before finishing with previous ones\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; rejected abort promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; rejected close promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = true\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel = true\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel omitted (but cancel is never called)\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel = true\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel = true\n[PASS] Errors must be propagated backward: erroring via the controller errors once pending write completes\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write; preventClose = true\n[PASS] Closing must be propagated forward: erroring the writable while flushing pending writes should error pipeTo\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; fulfilled abort promise\n[PASS] Piping to a WritableStream that does not consume the writes fast enough exerts backpressure on the ReadableStream\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; rejected abort promise\n[PASS] idl_test validation\n[PASS] ReadableStreamDefaultReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStreamBYOBReader includes ReadableStreamGenericReader: member names are unique\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = true\n[PASS] ReadableStream interface: existence and properties of interface object\n[PASS] ReadableStream interface object length\n[PASS] ReadableStream interface object name\n[PASS] ReadableStream interface: existence and properties of interface prototype object\n[PASS] ReadableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStream interface: operation from(any)\n[PASS] ReadableStream interface: operation getReader(optional ReadableStreamGetReaderOptions)\n[PASS] ReadableStream interface: operation pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\n[PASS] ReadableStream interface: operation tee()\n[PASS] ReadableStream interface: async iterable<any>\n[PASS] ReadableStream must be primary interface of new ReadableStream()\n[PASS] Stringification of new ReadableStream()\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"from(any)\" with the proper type\n[PASS] ReadableStream interface: calling from(any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"locked\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStream interface: calling cancel(optional any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"getReader(optional ReadableStreamGetReaderOptions)\" with the proper type\n[PASS] ReadableStream interface: calling getReader(optional ReadableStreamGetReaderOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: calling pipeThrough(ReadableWritablePair, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeTo(WritableStream, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"tee()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultReader interface object length\n[PASS] ReadableStreamDefaultReader interface object name\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultReader interface: operation releaseLock()\n[PASS] ReadableStreamDefaultReader must be primary interface of (new ReadableStream()).getReader()\n[PASS] Stringification of (new ReadableStream()).getReader()\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"read()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"closed\" with the proper type\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: calling cancel(optional any) on (new ReadableStream()).getReader() with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBReader interface object length\n[PASS] ReadableStreamBYOBReader interface object name\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBReader interface: operation releaseLock()\n[PASS] ReadableStreamBYOBReader must be primary interface of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] Stringification of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"read(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: calling cancel(optional any) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultController interface object length\n[PASS] ReadableStreamDefaultController interface object name\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultController interface: operation close()\n[PASS] ReadableStreamDefaultController interface: operation enqueue(optional any)\n[PASS] ReadableStreamDefaultController interface: operation error(optional any)\n[PASS] ReadableStreamDefaultController must be primary interface of self.readableStreamDefaultController\n[PASS] Stringification of self.readableStreamDefaultController\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"close()\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling enqueue(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling error(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: existence and properties of interface object\n[PASS] ReadableByteStreamController interface object length\n[PASS] ReadableByteStreamController interface object name\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableByteStreamController interface: operation close()\n[PASS] ReadableByteStreamController interface: operation enqueue(ArrayBufferView)\n[PASS] ReadableByteStreamController interface: operation error(optional any)\n[PASS] ReadableByteStreamController must be primary interface of self.readableByteStreamController\n[PASS] Stringification of self.readableByteStreamController\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"byobRequest\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"close()\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"enqueue(ArrayBufferView)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling enqueue(ArrayBufferView) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling error(optional any) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBRequest interface object length\n[PASS] ReadableStreamBYOBRequest interface object name\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBRequest interface: operation respond(unsigned long long)\n[PASS] ReadableStreamBYOBRequest interface: operation respondWithNewView(ArrayBufferView)\n[PASS] ReadableStreamBYOBRequest must be primary interface of self.readableStreamByobRequest\n[PASS] Stringification of self.readableStreamByobRequest\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"view\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respond(unsigned long long)\" with the proper type\n[EXPECTED_FAILURE][FAIL] enqueue() must not synchronously call write algorithm\nassert_false: write algorithm must not run synchronously expected false got true\n    at Test.<anonymous> (C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\fixtures\\wpt\\streams\\piping\\general-addition.any.js:14:3)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'piping\\general-addition.any.js'\n\n[PASS] ReadableStreamBYOBRequest interface: calling respond(unsigned long long) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respondWithNewView(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respondWithNewView(ArrayBufferView) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] WritableStream interface: existence and properties of interface object\n[PASS] WritableStream interface object length\n[PASS] WritableStream interface object name\n[PASS] WritableStream interface: existence and properties of interface prototype object\n[PASS] WritableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStream interface: operation getWriter()\n[PASS] WritableStream must be primary interface of new WritableStream()\n[PASS] Stringification of new WritableStream()\n[PASS] Piping must lock both the ReadableStream and WritableStream\n[PASS] WritableStream interface: new WritableStream() must inherit property \"locked\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStream interface: calling abort(optional any) on new WritableStream() with too few arguments must throw TypeError\n[PASS] WritableStream interface: new WritableStream() must inherit property \"close()\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"getWriter()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface object\n[PASS] WritableStreamDefaultWriter interface object length\n[PASS] WritableStreamDefaultWriter interface object name\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] WritableStreamDefaultWriter interface: operation releaseLock()\n[PASS] WritableStreamDefaultWriter must be primary interface of (new WritableStream()).getWriter()\n[PASS] Stringification of (new WritableStream()).getWriter()\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"closed\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"desiredSize\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"ready\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling abort(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"close()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"releaseLock()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"write(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling write(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultController interface: existence and properties of interface object\n[PASS] WritableStreamDefaultController interface object length\n[PASS] WritableStreamDefaultController interface object name\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStreamDefaultController interface: operation error(optional any)\n[PASS] WritableStreamDefaultController must be primary interface of self.writableStreamDefaultController\n[PASS] Stringification of self.writableStreamDefaultController\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"signal\" with the proper type\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] WritableStreamDefaultController interface: calling error(optional any) on self.writableStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStream interface: existence and properties of interface object\n[PASS] TransformStream interface object length\n[PASS] TransformStream interface object name\n[PASS] TransformStream interface: existence and properties of interface prototype object\n[PASS] TransformStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStream must be primary interface of new TransformStream()\n[PASS] Stringification of new TransformStream()\n[PASS] TransformStream interface: new TransformStream() must inherit property \"readable\" with the proper type\n[PASS] TransformStream interface: new TransformStream() must inherit property \"writable\" with the proper type\n[PASS] TransformStreamDefaultController interface: existence and properties of interface object\n[PASS] TransformStreamDefaultController interface object length\n[PASS] TransformStreamDefaultController interface object name\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Piping finishing must unlock both the ReadableStream and WritableStream\n[PASS] pipeTo must check the brand of its ReadableStream this value\n[PASS] pipeTo must check the brand of its WritableStream argument\n[PASS] pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream\n[PASS] pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream\n[PASS] TransformStreamDefaultController interface: operation enqueue(optional any)\n[PASS] TransformStreamDefaultController interface: operation error(optional any)\n[PASS] Piping from a ReadableStream from which lots of chunks are synchronously readable\n[PASS] TransformStreamDefaultController interface: operation terminate()\n[PASS] TransformStreamDefaultController must be primary interface of self.transformStreamDefaultController\n[PASS] Stringification of self.transformStreamDefaultController\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling enqueue(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling error(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"terminate()\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface object\n[PASS] ByteLengthQueuingStrategy interface object length\n[PASS] ByteLengthQueuingStrategy interface object name\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ByteLengthQueuingStrategy must be primary interface of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] CountQueuingStrategy interface: existence and properties of interface object\n[PASS] CountQueuingStrategy interface object length\n[PASS] CountQueuingStrategy interface object name\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] CountQueuingStrategy must be primary interface of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] ReadableStream interface: attribute locked\n[PASS] ReadableStreamDefaultController interface: attribute desiredSize\n[PASS] ReadableByteStreamController interface: attribute byobRequest\n[PASS] ReadableByteStreamController interface: attribute desiredSize\n[PASS] ReadableStreamBYOBRequest interface: attribute view\n[PASS] WritableStream interface: attribute locked\n[PASS] WritableStreamDefaultWriter interface: attribute desiredSize\n[PASS] WritableStreamDefaultController interface: attribute signal\n[PASS] TransformStream interface: attribute readable\n[PASS] TransformStream interface: attribute writable\n[PASS] TransformStreamDefaultController interface: attribute desiredSize\n[PASS] ByteLengthQueuingStrategy interface: attribute highWaterMark\n[PASS] ByteLengthQueuingStrategy interface: attribute size\n[PASS] CountQueuingStrategy interface: attribute highWaterMark\n[PASS] CountQueuingStrategy interface: attribute size\n[PASS] idl_test setup\n[PASS] ReadableStream interface: operation cancel(optional any)\n[PASS] ReadableStream interface: operation pipeTo(WritableStream, optional StreamPipeOptions)\n[PASS] ReadableStream interface: calling pipeTo(WritableStream, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultReader interface: operation read()\n[PASS] ReadableStreamDefaultReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: operation read(ArrayBufferView)\n[PASS] ReadableStreamBYOBReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: calling read(ArrayBufferView) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] WritableStream interface: operation abort(optional any)\n[PASS] WritableStream interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation abort(optional any)\n[PASS] WritableStreamDefaultWriter interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation write(optional any)\n[PASS] ReadableStreamDefaultReader interface: attribute closed\n[PASS] ReadableStreamBYOBReader interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute ready\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = true\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is true\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is false\n[PASS] pipeTo() should reject if an option getter grabs a writer\n[PASS] pipeTo() promise should resolve if null is passed\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; preventAbort = true\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write\n[PASS] pipeThrough should not call pipeTo on this\n[PASS] pipeThrough should not call pipeTo on the ReadableStream prototype\n[PASS] pipeThrough should brand-check this and not allow 'null'\n[PASS] pipeThrough should brand-check readable and not allow 'null'\n[PASS] Piping from an errored readable stream to an erroring writable stream\n[PASS] pipeThrough should brand-check this and not allow 'undefined'\n[PASS] pipeThrough should brand-check readable and not allow 'undefined'\n[PASS] Piping from an errored readable stream to an errored writable stream\n[PASS] pipeThrough should brand-check this and not allow '0'\n[PASS] pipeThrough should brand-check readable and not allow '0'\n[PASS] Piping from an errored readable stream to an erroring writable stream; preventAbort = true\n[PASS] pipeThrough should brand-check this and not allow 'NaN'\n[PASS] pipeThrough should brand-check readable and not allow 'NaN'\n[PASS] pipeThrough should brand-check this and not allow 'true'\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write; preventAbort = true\n[PASS] pipeThrough should brand-check readable and not allow 'true'\n[PASS] pipeThrough should brand-check this and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check readable and not allow 'ReadableStream'\n[PASS] piping should not be observable\n[PASS] pipeThrough should brand-check this and not allow '[object ReadableStream]'\n[PASS] Piping from an errored readable stream to an errored writable stream; preventAbort = true\n[PASS] pipeThrough should brand-check readable and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check writable and not allow 'null'\n[PASS] pipeThrough should brand-check writable and not allow 'undefined'\n[PASS] pipeThrough should brand-check writable and not allow '0'\n[PASS] pipeThrough should brand-check writable and not allow 'NaN'\n[PASS] pipeThrough should brand-check writable and not allow 'true'\n[PASS] pipeThrough should brand-check writable and not allow 'WritableStream'\n[PASS] pipeThrough should brand-check writable and not allow '[object WritableStream]'\n[PASS] pipeThrough should rethrow errors from accessing readable or writable\n[PASS] invalid values of signal should throw; specifically 'null'\n[PASS] invalid values of signal should throw; specifically '0'\n[PASS] invalid values of signal should throw; specifically 'NaN'\n[PASS] invalid values of signal should throw; specifically 'true'\n[PASS] invalid values of signal should throw; specifically 'AbortSignal'\n[PASS] tee should not be observable\n[PASS] Piping from an errored readable stream to a closing writable stream\n[PASS] invalid values of signal should throw; specifically '[object AbortSignal]'\n[PASS] pipeThrough should accept a real AbortSignal\n[PASS] pipeThrough should throw if this is locked\n[PASS] pipeThrough should throw if writable is locked\n[PASS] pipeThrough should not care if readable is locked\n[PASS] pipeThrough() should throw if an option getter grabs a writer\n[PASS] pipeThrough() should not throw if option is null\n[PASS] pipeThrough() should not throw if signal is undefined\n[PASS] pipeThrough() should throw if readable/writable getters throw\n[PASS] Piping from an errored readable stream to a closed writable stream\n[PASS] Piping from a closed readable stream to an erroring writable stream\n[PASS] Piping from a closed readable stream to an errored writable stream\n[PASS] Piping from a closed readable stream to a closed writable stream\n[PASS] Piping through a duck-typed pass-through transform stream should work\n[PASS] Piping through a transform errored on the writable end does not cause an unhandled promise rejection\n[PASS] preventCancel should work\n[PASS] preventClose should work\n[PASS] preventAbort should work\n[PASS] pipeThrough should stop after getting preventAbort throws\n[PASS] pipeThrough should stop after getting preventCancel throws\n[PASS] pipeThrough should stop after getting preventClose throws\n[PASS] pipeThrough should stop after getting signal throws\n[PASS] pipeTo should stop after getting preventAbort throws\n[PASS] pipeTo should stop after getting preventCancel throws\n[PASS] pipeTo should stop after getting preventClose throws\n[PASS] pipeTo should stop after getting signal throws\n[PASS] Piping through an identity transform stream should close the destination when the source closes\n[PASS] CountQueuingStrategy: Can construct a with a valid high water mark\n[PASS] CountQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] CountQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] CountQueuingStrategy: size is the same function across all instances\n[PASS] CountQueuingStrategy: size should have the right name\n[PASS] CountQueuingStrategy: subclassing should work correctly\n[PASS] CountQueuingStrategy: size should not have a prototype property\n[PASS] ByteLengthQueuingStrategy: Can construct a with a valid high water mark\n[PASS] ByteLengthQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] ByteLengthQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] ByteLengthQueuingStrategy: size is the same function across all instances\n[PASS] ByteLengthQueuingStrategy: size should have the right name\n[PASS] ByteLengthQueuingStrategy: subclassing should work correctly\n[PASS] ByteLengthQueuingStrategy: size should not have a prototype property\n[PASS] CountQueuingStrategy: size should not be a constructor\n[PASS] ByteLengthQueuingStrategy: size should not be a constructor\n[PASS] CountQueuingStrategy: size should have the right length\n[PASS] ByteLengthQueuingStrategy: size should have the right length\n[PASS] CountQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ByteLengthQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ReadableStream with byte source: enqueuing an already-detached buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length view on a non-zero-length buffer throws\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is zero-length on a non-zero-length buffer (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (autoAllocateChunkSize)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a larger length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is non-zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the closed state)\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: read()ing from a closed stream still transfers the buffer\n[PASS] ReadableStream with byte source: read()ing from a stream with queued chunks still transfers the buffer\n[PASS] ReadableStream with byte source: reading into an already-detached buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length buffer rejects\n[PASS] enqueue after detaching byobRequest.view.buffer should throw\n[PASS] ReadableStream with byte source: reading into a zero-length view on a non-zero-length buffer rejects\n[PASS] getReader({mode: \"byob\"}) throws on non-bytes streams\n[PASS] ReadableStream with byte source can be constructed with no errors\n[PASS] getReader({mode}) must perform ToString()\n[PASS] ReadableStream with byte source: start() throws an exception\n[PASS] ReadableStream with byte source: desiredSize when closed\n[PASS] ReadableStream with byte source: desiredSize when errored\n[PASS] ReadableStream with byte source: pull() function is not callable\n[PASS] ReadableStream with byte source: Throw if close()-ed more than once\n[PASS] ReadableStream with byte source: Throw on enqueue() after close()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize cannot be 0\n[PASS] ReadableStreamBYOBReader can be constructed directly\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream argument\n[PASS] ReadableStreamBYOBReader constructor requires an unlocked ReadableStream\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream with type \"bytes\"\n[PASS] ReadableStream constructor should not accept a strategy with a size defined if type is \"bytes\"\n[PASS] ReadableStream with byte source: Construct and expect start and pull being called\n[PASS] ReadableStream with byte source: No automatic pull call if start doesn't finish\n[PASS] ReadableStream with byte source: Construct with highWaterMark of 0\n[PASS] ReadableStream with byte source: getReader(), then releaseLock()\n[PASS] ReadableStream with byte source: getReader() with mode set to byob, then releaseLock()\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: releaseLock() on ReadableStreamDefaultReader must reject pending read()\n[PASS] ReadableStream with byte source: releaseLock() on ReadableStreamBYOBReader must reject pending read()\n[PASS] ReadableStream with byte source: Automatic pull() after start()\n[PASS] ReadableStream with byte source: Automatic pull() after start() and read()\n[PASS] ReadableStream with byte source: autoAllocateChunkSize\n[PASS] ReadableStream with byte source: Mix of auto allocate and BYOB\n[PASS] ReadableStream with byte source: Automatic pull() after start() and read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read()\n[PASS] ReadableStream with byte source: Push source that doesn't understand pull signal\n[PASS] ReadableStream with byte source: enqueue() with Uint16Array, getReader(), then read()\n[PASS] ReadableStream with byte source: enqueue(), read(view) partially, then read()\n[PASS] ReadableStream with byte source: getReader(), enqueue(), close(), then read()\n[PASS] ReadableStream with byte source: enqueue(), close(), getReader(), then read()\n[PASS] ReadableStream with byte source: Respond to pull() by enqueue()\n[PASS] ReadableStream with byte source: Respond to pull() by enqueue() asynchronously\n[PASS] ReadableStream with byte source: Respond to multiple pull() by separate enqueue()\n[PASS] ReadableStream with byte source: read(view), then respond()\n[PASS] ReadableStream with byte source: read(view), then respondWithNewView() with a transferred ArrayBuffer\n[PASS] ReadableStream with byte source: read(view), then respond() with too big value\n[PASS] ReadableStream with byte source: respond(3) to read(view) with 2 element Uint16Array enqueues the 1 byte remainder\n[PASS] ReadableStream with byte source: enqueue() with a non-transferable buffer\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = not BYOB)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = BYOB)\n[PASS] ReadableStream with byte source: getReader(), read(view), then cancel()\n[PASS] ReadableStream with byte source: read() with a non-transferable buffer\n[PASS] ReadableStream with byte source: cancel() with partially filled pending pull() request\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) where view.buffer is not fully covered by view\n[PASS] ReadableStream with byte source: fill() with a non-transferable buffer\n[PASS] ReadableStream with byte source: Multiple enqueue(), getReader(), then read(view)\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) with a bigger view\n[PASS] ReadableStream with byte source: enqueue(), getReader(), then read(view) with smaller views\n[PASS] ReadableStream with byte source: enqueue() 1 byte, getReader(), then read(view) with Uint16Array\n[PASS] ReadableStream with byte source: respondWithNewView() with a non-transferable buffer\n[PASS] ReadableStream with byte source: enqueue() 3 byte, getReader(), then read(view) with 2-element Uint16Array\n[PASS] ReadableStream with byte source: read(view) with Uint16Array on close()-d stream with 1 byte enqueue()-d must fail\n[PASS] ReadableStream with byte source: A stream must be errored if close()-d before fulfilling read(view) with Uint16Array\n[PASS] ReadableStream with byte source: read(view), then respond() and close() in pull()\n[PASS] ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple respond() calls\n[PASS] ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple enqueue() calls\n[PASS] ReadableStream with byte source: read() twice, then enqueue() twice\n[PASS] ReadableStream with byte source: Multiple read(view), close() and respond()\n[PASS] ReadableStream with byte source: Multiple read(view), big enqueue()\n[PASS] ReadableStream with byte source: Multiple read(view) and multiple enqueue()\n[PASS] ReadableStream with byte source: read(view) with passing undefined as view must fail\n[PASS] ReadableStream with byte source: read(view) with passing an empty object as view must fail\n[PASS] ReadableStream with byte source: Even read(view) with passing ArrayBufferView like object as view must fail\n[PASS] ReadableStream with byte source: read() on an errored stream\n[PASS] ReadableStream with byte source: read(), then error()\n[PASS] ReadableStream with byte source: read(view) on an errored stream\n[PASS] ReadableStream with byte source: read(view), then error()\n[PASS] ReadableStream with byte source: Throwing in pull function must error the stream\n[PASS] ReadableStream with byte source: Throwing in pull in response to read() must be ignored if the stream is errored in it\n[PASS] ReadableStream with byte source: Throwing in pull in response to read(view) function must error the stream\n[PASS] ReadableStream with byte source: Throwing in pull in response to read(view) must be ignored if the stream is errored in it\n[PASS] calling respond() twice on the same byobRequest should throw\n[PASS] calling respondWithNewView() twice on the same byobRequest should throw\n[PASS] calling respond(0) twice on the same byobRequest should throw even when closed\n[PASS] calling respond() should throw when canceled\n[PASS] pull() resolving should not resolve read()\n[PASS] ReadableStream with byte source: default reader + autoAllocateChunkSize + byobRequest interaction\n[PASS] ReadableStream with byte source: respondWithNewView() with a smaller view\n[PASS] ReadableStream with byte source: respondWithNewView() with a zero-length view (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() with a transferred non-zero-length view (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() with a transferred zero-length view (in the closed state)\n[PASS] ReadableStream with byte source: enqueue() discards auto-allocated BYOB request\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is 0\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is negative\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint8Array)\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (Uint16Array)\n[PASS] ReadableStream with byte source: read({ min }) rejects if min is larger than view's length (DataView)\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respond()\n[PASS] ReadableStream with byte source: read({ min }), then read()\n[PASS] ReadableStream with byte source: read({ min }) with a DataView\n[PASS] byobRequest.respond() after enqueue() should not crash\n[PASS] ReadableStream with byte source: enqueue(), then read({ min })\n[PASS] byobRequest.respond() with cached byobRequest after enqueue() should not crash\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 3-byte Uint8Array, then multiple enqueue() up to 3 bytes\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 1 element Uint16Array, respond(1)\n[PASS] byobRequest.respond() after enqueue() with double read should not crash\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 3 bytes\n[PASS] ReadableStream with byte source: read({ min: 3 }) on a 5-byte Uint8Array, then multiple enqueue() up to 4 bytes\n[PASS] ReadableStream with byte source: enqueue(), read({ min }) partially, then read()\n[PASS] ReadableStream with byte source: read({ min }), then respondWithNewView() with a transferred ArrayBuffer\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader with 2 element Uint8Array, respond(3)\n[PASS] ReadableStream with byte source: read({ min }) on a closed stream\n[PASS] ReadableStream with byte source: read({ min }) when closed before view is filled\n[PASS] ReadableStream with byte source: read({ min }) when closed immediately after view is filled\n[PASS] ReadableStream with byte source: read({ min }) on an errored stream\n[PASS] ReadableStream with byte source: read({ min }), then error()\n[PASS] ReadableStream with byte source: getReader(), read({ min }), then cancel()\n[PASS] ReadableStream with byte source: cancel() with partially filled pending read({ min }) request\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, respondWithNewView()\n[PASS] ReadableStream with byte source: enqueue(), then read({ min }) with smaller views\n[PASS] ReadableStream with byte source: 3 byte enqueue(), then close(), then read({ min }) with 2-element Uint16Array must fail\n[PASS] ReadableStream with byte source: read({ min }) with 2-element Uint16Array, then 3 byte enqueue(), then close() must fail\n[PASS] ReadableStream with byte source: tee() with read({ min }) from branch1 and read() from branch2\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, enqueue()\n[PASS] ReadableStream teeing with byte source: rs.tee() returns an array of two ReadableStreams\n[PASS] Running templatedRSTeeCancel with ReadableStream teeing with byte source\n[PASS] ReadableStream with byte source: releaseLock() with pending read(view), read(view) on second reader, close(), respond(0)\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, respond()\n[PASS] ReadableStream teeing with byte source: should be able to read one branch to the end without affecting the other\n[PASS] ReadableStream teeing with byte source: chunks should be cloned for each branch\n[PASS] ReadableStream teeing with byte source: chunks for BYOB requests from branch 1 should be cloned to branch 2\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read() on second reader, enqueue()\n[PASS] Async iterator instances should have the correct list of properties\n[PASS] values() throws if there's already a lock\n[PASS] ReadableStream teeing with byte source: errors in the source should propagate to both branches\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, respond()\n[PASS] ReadableStream teeing with byte source: canceling branch1 should not impact branch2\n[PASS] return() should unlock the stream synchronously when preventCancel = false\n[PASS] return() should unlock the stream synchronously when preventCancel = true\n[PASS] ReadableStream teeing with byte source: canceling branch2 should not impact branch1\n[PASS] ReadableStream teeing with byte source: canceling both branches should aggregate the cancel reasons into an array\n[PASS] Readable stream: throwing strategy.size getter\n[PASS] Readable stream: throwing strategy.highWaterMark getter\n[PASS] ReadableStream teeing with byte source: canceling both branches in reverse order should aggregate the cancel reasons into an array\n[PASS] Async-iterating a push source\n[PASS] ReadableStream teeing with byte source: failing to cancel the original stream should cause cancel() to reject on branches\n[PASS] Async-iterating a pull source\n[PASS] Readable stream: invalid strategy.highWaterMark\n[PASS] ReadableStream teeing with byte source: erroring a teed stream should properly handle canceled branches\n[PASS] ReadableStream teeing with byte source: closing the original should close the branches\n[PASS] ReadableStream teeing with byte source: erroring the original should immediately error the branches\n[PASS] ReadableStream teeing with byte source: erroring the original should error pending reads from default reader\n[PASS] Async-iterating a push source with undefined values\n[PASS] ReadableStream teeing with byte source: erroring the original should error pending reads from BYOB reader\n[PASS] Readable stream: strategy.size errors the stream and then throws\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, releaseLock() with pending read(), read(view) on second reader, enqueue()\n[PASS] Async-iterating a pull source with undefined values\n[PASS] Readable stream: strategy.size errors the stream and then returns Infinity\n[PASS] ReadableStream teeing with byte source: canceling branch1 should finish when branch2 reads until end of stream\n[PASS] ReadableStream teeing with byte source: canceling branch1 should finish when original stream errors\n[PASS] Readable stream: throwing strategy.size method\n[PASS] Async-iterating a pull source manually\n[PASS] Async-iterating an errored stream throws\n[PASS] Readable stream: invalid strategy.size return value\n[PASS] Async-iterating a closed stream never executes the loop body, but works fine\n[PASS] Readable stream: invalid strategy.size return value when pulling\n[PASS] ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read(view) on second reader with 1 element Uint16Array, respond(1)\n[PASS] ReadableStream teeing with byte source: should not pull any chunks if no branches are reading\n[PASS] ReadableStream teeing with byte source: should only pull enough to fill the emptiest queue\n[PASS] Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function\n[PASS] ReadableStream with byte source: read(view) with 1 element Uint16Array, respond(1), releaseLock(), read() on second reader, enqueue()\n[PASS] Async-iterating a partially consumed stream\n[PASS] ReadableStream with byte source: autoAllocateChunkSize, read(), respondWithNewView()\n[PASS] Cancellation behavior when throwing inside loop body; preventCancel = false\n[PASS] Cancellation behavior when throwing inside loop body; preventCancel = true\n[PASS] Cancellation behavior when breaking inside loop body; preventCancel = false\n[PASS] Cancellation behavior when breaking inside loop body; preventCancel = true\n[PASS] Cancellation behavior when returning inside loop body; preventCancel = false\n[PASS] Cancellation behavior when returning inside loop body; preventCancel = true\n[PASS] Cancellation behavior when manually calling return(); preventCancel = false\n[PASS] Cancellation behavior when manually calling return(); preventCancel = true\n[PASS] next() rejects if the stream errors\n[PASS] return() does not rejects if the stream has not errored yet\n[PASS] ReadableStream teeing with byte source: should not pull when original is already errored\n[PASS] return() rejects if the stream has errored\n[PASS] next() that succeeds; next() that reports an error; next()\n[PASS] next() that succeeds; next() that reports an error(); next() [no awaiting]\n[PASS] next() that succeeds; next() that reports an error(); return()\n[PASS] next() that succeeds; next() that reports an error(); return() [no awaiting]\n[PASS] next() that succeeds; return()\n[PASS] next() that succeeds; return() [no awaiting]\n[PASS] return(); next()\n[PASS] return(); next() [no awaiting]\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while branch 1 is reading\n[PASS] return(); next() with delayed cancel()\n[PASS] return(); next() with delayed cancel() [no awaiting]\n[PASS] return(); return()\n[PASS] return(); return() [no awaiting]\n[PASS] Acquiring a reader after exhaustively async-iterating a stream\n[PASS] Acquiring a reader after return()ing from a stream that errors\n[PASS] Acquiring a reader after partially async-iterating a stream\n[PASS] Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true\n[PASS] close() while next() is pending\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while branch 2 is reading\n[PASS] Underlying source start: throwing getter\n[PASS] Underlying source start: throwing method\n[PASS] Underlying source: throwing pull getter (initial pull)\n[PASS] Underlying source cancel: throwing getter\n[PASS] Underlying source: throwing pull method (initial pull)\n[PASS] Underlying source pull: throwing getter (second pull does not result in a second get)\n[PASS] Underlying source pull: throwing method (second pull)\n[PASS] Underlying source cancel: throwing method\n[PASS] Underlying source: calling enqueue on an empty canceled stream should throw\n[PASS] ReadableStream teeing with byte source: stops pulling when original stream errors while both branches are reading\n[PASS] Underlying source: calling enqueue on a non-empty canceled stream should throw\n[PASS] Underlying source: calling enqueue on a closed stream should throw\n[PASS] Underlying source: calling enqueue on an errored stream should throw\n[PASS] Underlying source: calling close twice on an empty stream should throw the second time\n[PASS] Underlying source: calling close twice on a non-empty stream should throw the second time\n[PASS] Underlying source: calling close on an empty canceled stream should throw\n[PASS] Underlying source: calling close on a non-empty canceled stream should throw\n[PASS] Underlying source: calling close after error should throw\n[PASS] Underlying source: calling error twice should not throw\n[PASS] Underlying source: calling error after close should not throw\n[PASS] Underlying source: calling error and returning a rejected promise from start should cause the stream to error with the first error\n[PASS] Underlying source: calling error and returning a rejected promise from pull should cause the stream to error with the first error\n[PASS] read should not error if it dequeues and pull() throws\n[PASS] ReadableStream teeing with byte source: canceling both branches in sequence with delay\n[PASS] ReadableStream teeing with byte source: failing to cancel when canceling both branches in sequence with delay\n[PASS] ReadableStream cancellation: cancel(reason) should pass through the given reason to the underlying source\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, cancel branch2\n[PASS] underlyingSource argument should be converted after queuingStrategy argument\n[PASS] ReadableStream cancellation: integration test on an infinite stream derived from a random push source\n[PASS] ReadableStream cancellation: cancel() on a locked stream should fail and not call the underlying source cancel\n[PASS] ReadableStream cancellation: should fulfill promise when cancel callback went fine\n[PASS] ReadableStream cancellation: returning a value from the underlying source's cancel should not affect the fulfillment value of the promise returned by the stream's cancel\n[PASS] ReadableStream cancellation: should reject promise when cancel callback raises an exception\n[PASS] ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (1)\n[PASS] ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should fulfill when that one does (2)\n[PASS] ReadableStream cancellation: if the underlying source's cancel method returns a promise, the promise returned by the stream's cancel should reject when that one does\n[PASS] ReadableStream cancellation: cancelling before start finishes should prevent pull() from being called\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, cancel branch1\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch2, enqueue to branch1\n[PASS] Can construct a readable stream with a valid CountQueuingStrategy\n[PASS] Correctly governs a ReadableStreamController's desiredSize property (HWM = 0)\n[PASS] Correctly governs a ReadableStreamController's desiredSize property (HWM = 1)\n[PASS] Correctly governs a ReadableStreamController's desiredSize property (HWM = 4)\n[PASS] ReadableStreamDefaultReader constructor should get a ReadableStream object as argument\n[PASS] ReadableStreamDefaultReader closed should always return the same promise object\n[PASS] Constructing a ReadableStreamDefaultReader directly should fail if the stream is already locked (via direct construction)\n[PASS] Getting a ReadableStreamDefaultReader via getReader should fail if the stream is already locked (via direct construction)\n[PASS] ReadableStream teeing with byte source: read from branch1 and branch2, cancel branch1, respond to branch2\n[PASS] Constructing a ReadableStreamDefaultReader directly should fail if the stream is already locked (via getReader)\n[PASS] Getting a ReadableStreamDefaultReader via getReader should fail if the stream is already locked (via getReader)\n[PASS] Constructing a ReadableStreamDefaultReader directly should be OK if the stream is closed\n[PASS] Constructing a ReadableStreamDefaultReader directly should be OK if the stream is errored\n[PASS] ReadableStream teeing with byte source: pull with BYOB reader, then pull with default reader\n[PASS] getReader() should call ToString() on mode\n[PASS] ReadableStream teeing with byte source: pull with default reader, then pull with BYOB reader\n[PASS] Reading from a reader for an empty stream will wait until a chunk is available\n[PASS] cancel() on a reader does not release the reader\n[PASS] closed should be fulfilled after stream is closed (.closed access before acquiring)\n[PASS] closed should be rejected after reader releases its lock (multiple stream locks)\n[PASS] closed is replaced when stream closes and reader releases its lock\n[PASS] closed is replaced when stream errors and reader releases its lock\n[PASS] Multiple readers can access the stream in sequence\n[PASS] Cannot use an already-released reader to unlock a stream again\n[PASS] cancel() on a released reader is a no-op and does not pass through\n[PASS] Getting a second reader after erroring the stream and releasing the reader should succeed\n[PASS] ReadableStreamDefaultReader closed promise should be rejected with undefined if that is the error\n[PASS] ReadableStreamDefaultReader: if start rejects with no parameter, it should error the stream with an undefined error\n[PASS] Erroring a ReadableStream after checking closed should reject ReadableStreamDefaultReader closed promise\n[PASS] Erroring a ReadableStream before checking closed should reject ReadableStreamDefaultReader closed promise\n[PASS] Reading twice on a stream that gets closed\n[PASS] Reading twice on a closed stream\n[PASS] Reading twice on an errored stream\n[PASS] Reading twice on a stream that gets errored\n[PASS] ReadableStream teeing with byte source: read from branch2, then read from branch1\n[PASS] controller.close() should clear the list of pending read requests\n[PASS] Second reader can read chunks after first reader was released with pending read requests\n[PASS] ReadableStream teeing with byte source: read from branch1 with default reader, then close while branch2 has pending BYOB read\n[PASS] Floating point arithmetic must manifest near NUMBER.MAX_SAFE_INTEGER (total ends up positive)\n[PASS] Floating point arithmetic must manifest near 0 (total ends up positive, but clamped)\n[PASS] Floating point arithmetic must manifest near 0 (total ends up positive, and not clamped)\n[PASS] Floating point arithmetic must manifest near 0 (total ends up zero)\n[PASS] ReadableStream teeing with byte source: read from branch2 with default reader, then close while branch1 has pending BYOB read\n[PASS] ReadableStream teeing with byte source: close when both branches have pending BYOB reads\n[PASS] ReadableStream.from throws on invalid iterables; specifically null\n[PASS] ReadableStream.from throws on invalid iterables; specifically undefined\n[PASS] ReadableStream.from throws on invalid iterables; specifically 0\n[PASS] ReadableStream.from throws on invalid iterables; specifically NaN\n[PASS] ReadableStream.from throws on invalid iterables; specifically true\n[PASS] ReadableStream.from throws on invalid iterables; specifically {}\n[PASS] ReadableStream.from throws on invalid iterables; specifically Object.create(null)\n[PASS] ReadableStream.from throws on invalid iterables; specifically a function\n[PASS] ReadableStream.from throws on invalid iterables; specifically a symbol\n[PASS] ReadableStream.from throws on invalid iterables; specifically an object with a non-callable @@iterator method\n[PASS] ReadableStream teeing with byte source: enqueue() and close() while both branches are pulling\n[PASS] ReadableStream.from throws on invalid iterables; specifically an object with a non-callable @@asyncIterator method\n[PASS] ReadableStream.from re-throws errors from calling the @@iterator method\n[PASS] ReadableStream.from re-throws errors from calling the @@asyncIterator method\n[PASS] ReadableStream.from ignores @@iterator if @@asyncIterator exists\n[PASS] ReadableStream teeing with byte source: respond() and close() while both branches are pulling\n[PASS] ReadableStream.from accepts an array of values\n[PASS] ReadableStream.from accepts an array of promises\n[PASS] ReadableStream.from accepts an array iterator\n[PASS] ReadableStream.from accepts a string\n[PASS] ReadableStream.from accepts a Set\n[PASS] ReadableStream.from accepts a Set iterator\n[PASS] ReadableStream.from accepts a sync generator\n[PASS] ReadableStream.from accepts an async generator\n[PASS] ReadableStream.from accepts a sync iterable of values\n[PASS] ReadableStream.from accepts a sync iterable of promises\n[PASS] ReadableStream.from accepts an async iterable\n[PASS] ReadableStream.from accepts a ReadableStream\n[PASS] ReadableStream.from accepts a ReadableStream async iterator\n[PASS] ReadableStream.from accepts an empty iterable\n[PASS] ReadableStream.from: stream errors when next() rejects\n[PASS] ReadableStream.from: stream stalls when next() never settles\n[PASS] ReadableStream.from: calls next() after first read()\n[PASS] ReadableStream.from: cancelling the returned stream calls and awaits return()\n[PASS] ReadableStream.from: return() is not called when iterator completes normally\n[PASS] ReadableStream.from: cancel() rejects when return() fulfills with a non-object\n[PASS] ReadableStream.from: reader.read() inside next()\n[PASS] ReadableStream.from: reader.cancel() inside next()\n[PASS] ReadableStream.from: reader.cancel() inside return()\n[PASS] ReadableStream.from(array), push() to array while reading\n[PASS] ReadableStream can be constructed with no errors\n[PASS] ReadableStream can't be constructed with garbage\n[PASS] ReadableStream can't be constructed with an invalid type\n[PASS] ReadableStream constructor should throw for non-function start arguments\n[PASS] ReadableStream constructor will not tolerate initial garbage as cancel argument\n[PASS] ReadableStream constructor will not tolerate initial garbage as pull argument\n[PASS] ReadableStream start should be called with the proper thisArg\n[PASS] ReadableStream start controller parameter should be extensible\n[PASS] default ReadableStream getReader() should only accept mode:undefined\n[PASS] ReadableStream: enqueue should throw when the stream is readable but draining\n[PASS] ReadableStream: enqueue should throw when the stream is closed\n[PASS] ReadableStream: desiredSize when closed\n[PASS] ReadableStream: desiredSize when errored\n[PASS] Subclassing ReadableStream should work\n[PASS] ReadableStream strategies: the default strategy should give desiredSize of 1 to start, decreasing by 1 per enqueue\n[PASS] ReadableStream should be able to call start method within prototype chain of its source\n[PASS] ReadableStream start should be able to return a promise\n[PASS] ReadableStream start should be able to return a promise and reject it\n[PASS] ReadableStream should be able to enqueue different objects.\n[PASS] ReadableStream: if pull rejects, it should error the stream\n[EXPECTED_FAILURE][FAIL] Transferred MessageChannel works as expected\npromise_test: Unhandled rejection with value: object \"TypeError [ERR_INVALID_ARG_VALUE]: The property 'source.type' is invalid. Received 'owning'\"\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'readable-streams\\owning-type-message-port.any.js'\n\n[EXPECTED_FAILURE][FAIL] Second branch of owning ReadableStream tee should end up into errors with transfer only values\npromise_test: Unhandled rejection with value: object \"TypeError [ERR_INVALID_ARG_VALUE]: The property 'source.type' is invalid. Received 'owning'\"\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'readable-streams\\owning-type-message-port.any.js'\n\n[PASS] ReadableStream tee() should not touch Object.prototype properties\n[PASS] ReadableStream tee() should not call the global ReadableStream\n[PASS] ReadableStream: should only call pull once upon starting the stream\n[PASS] tee() should not call Promise.prototype.then()\n[PASS] pipeTo() should not call Promise.prototype.then()\n[PASS] ReadableStream: should call pull when trying to read from a started, empty stream\n[PASS] ReadableStream async iterator should use the original values of getReader() and ReadableStreamDefaultReader methods\n[PASS] ReadableStream: should only call pull once on a non-empty stream read from before start fulfills\n[PASS] ReadableStreamController methods should continue working properly when scripts lose their reference to the readable stream\n[PASS] enqueue() inside size() should work\n[PASS] close() inside size() should not crash\n[PASS] close request inside size() should work\n[PASS] error() inside size() should work\n[PASS] ReadableStream: should only call pull once on a non-empty stream read from after start fulfills\n[PASS] desiredSize inside size() should work\n[PASS] cancel() inside size() should work\n[PASS] pipeTo() inside size() should behave as expected\n[PASS] ReadableStream: should call pull in reaction to read()ing the last chunk, if not draining\n[PASS] read() inside of size() should behave as expected\n[PASS] getReader() inside size() should work\n[PASS] tee() inside size() should work\n[PASS] ReadableStream: should not call pull() in reaction to read()ing the last chunk, if draining\n[PASS] ReadableStream teeing: rs.tee() returns an array of two ReadableStreams\n[PASS] Running templatedRSTeeCancel with ReadableStream teeing\n[PASS] ReadableStreamTee should not use a modified ReadableStream constructor from the global object\n[PASS] ReadableStream teeing: should be able to read one branch to the end without affecting the other\n[PASS] ReadableStream teeing: values should be equal across each branch\n[PASS] ReadableStream: should not call pull until the previous pull call's promise fulfills\n[PASS] ReadableStream teeing: errors in the source should propagate to both branches\n[PASS] ReadableStream closed promise should fulfill even if the stream and reader JS references are lost\n[PASS] ReadableStream teeing: canceling branch1 should not impact branch2\n[PASS] ReadableStream teeing: canceling branch2 should not impact branch1\n[PASS] ReadableStream teeing: canceling both branches should aggregate the cancel reasons into an array\n[PASS] ReadableStream teeing: canceling both branches in reverse order should aggregate the cancel reasons into an array\n[PASS] ReadableStream teeing: failing to cancel the original stream should cause cancel() to reject on branches\n[PASS] ReadableStream teeing: erroring a teed stream should properly handle canceled branches\n[PASS] ReadableStream teeing: erroring a teed stream should error both branches\n[PASS] ReadableStream teeing: closing the original should immediately close the branches\n[PASS] ReadableStream teeing: erroring the original should immediately error the branches\n[PASS] ReadableStream teeing: canceling branch1 should finish when branch2 reads until end of stream\n[PASS] ReadableStream teeing: canceling branch1 should finish when original stream errors\n[PASS] ReadableStream: should pull after start, and after every read\n[PASS] ReadableStream teeing: canceling both branches in sequence with delay\n[PASS] ReadableStream: should not call pull after start if the stream is now closed\n[PASS] ReadableStream: should call pull after enqueueing from inside pull (with no read requests), if strategy allows\n[PASS] ReadableStream pull should be able to close a stream.\n[PASS] ReadableStream pull should be able to error a stream.\n[PASS] ReadableStream pull should be able to error a stream and throw.\n[PASS] ReadableStream: should call underlying source methods as methods\n[PASS] ReadableStream strategies: the default strategy should continue giving desiredSize of 1 if the chunks are read immediately\n[PASS] ReadableStream teeing: failing to cancel when canceling both branches in sequence with delay\n[PASS] ReadableStreamTee should not pull more chunks than can fit in the branch queue\n[PASS] ReadableStreamTee should only pull enough to fill the emptiest queue\n[PASS] ReadableStreamTee should not pull when original is already errored\n[PASS] ReadableStream integration test: adapting a random push source"},"time":1666.04,"fullname":"wpt/test-streams","closingTestPoint":false}}]}