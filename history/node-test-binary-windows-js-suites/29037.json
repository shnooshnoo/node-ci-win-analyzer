{"failedTests":[{"testName":"parallel/test-child-process-fork-exec-path","timestamp":1722499054777,"status":"FAILED","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 1,win11-arm64-COMPILED_BY-vs2022-arm64 #29037","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=1,nodes=win11-arm64-COMPILED_BY-vs2022-arm64/29037/","buildNumber":29037,"builtOn":"test-azure_msft-win11_vs2022-arm64-5","nodeVersion":"23.0.0","commitHash":"4491ee5ed65ede0ea0ff424fae8c7417205f1348","callStack":[{"upstreamBuild":64493,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":72669,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":60790,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"54142"}],"tap":{"ok":false,"name":"parallel/test-child-process-fork-exec-path","id":126,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":1,"stack":"Can't clean tmpdir: d:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\.tmp.112\nFiles blocking: [ 'node-copy.exe' ]\n\nd:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:69\n    throw e;\n    ^\n\nError: EPERM, Permission denied: \\\\?\\d:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\.tmp.112 '\\\\?\\d:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\.tmp.112'\n    at Object.rmSync (node:fs:1246:18)\n    at rmSync (d:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:20:8)\n    at onexit (d:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:54:5)\n    at process.<anonymous> (d:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\common\\tmpdir.js:43:14)\n    at process.emit (node:events:532:35) {\n  errno: 1,\n  code: 'EPERM',\n  path: '\\\\\\\\?\\\\d:\\\\workspace\\\\node-test-binary-windows-js-suites\\\\node\\\\test\\\\.tmp.112',\n  syscall: 'rm'\n}\n\nNode.js v23.0.0-pre"},"time":2909.994,"fullname":"parallel/test-child-process-fork-exec-path","closingTestPoint":false}},{"testName":"wpt/test-url","timestamp":1722499054777,"status":"REGRESSION","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 0,win2022-COMPILED_BY-vs2022 #29037","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=0,nodes=win2022-COMPILED_BY-vs2022/29037/","buildNumber":29037,"builtOn":"test-rackspace-win2022_vs2022-x64-1","nodeVersion":"23.0.0","commitHash":"4491ee5ed65ede0ea0ff424fae8c7417205f1348","callStack":[{"upstreamBuild":64493,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":72669,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":60790,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"54142"}],"tap":{"ok":false,"name":"wpt/test-url","id":1004,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"crashed","exitcode":3221225477,"stack":"[SKIPPED] idlharness-shadowrealm.window.js: ShadowRealm support is not enabled\n[SKIPPED] javascript-urls.window.js: requires document.body reference\n[SKIPPED] percent-encoding.window.js: TODO: port from .window.js\n[SKIPPED] url-setters-a-area.window.js?include=file: already tested in url-setters.any.js\n[SKIPPED] url-setters-a-area.window.js?include=javascript: already tested in url-setters.any.js\n[SKIPPED] url-setters-a-area.window.js?include=mailto: already tested in url-setters.any.js\n[SKIPPED] url-setters-a-area.window.js?exclude=(file|javascript|mailto): already tested in url-setters.any.js"},"time":1071.039,"fullname":"wpt/test-url","closingTestPoint":false}},{"testName":"wpt/test-streams","timestamp":1722499054777,"status":"REGRESSION","jobName":"node-test-binary-windows-js-suites","config":"node-test-binary-windows-js-suites » 1,win2019-COMPILED_BY-vs2022 #29037","buildUrl":"https://ci.nodejs.org/job/node-test-binary-windows-js-suites/RUN_SUBSET=1,nodes=win2019-COMPILED_BY-vs2022/29037/","buildNumber":29037,"builtOn":"test-rackspace-win2019_vs2019-x64-1","nodeVersion":"23.0.0","commitHash":"4491ee5ed65ede0ea0ff424fae8c7417205f1348","callStack":[{"upstreamBuild":64493,"upstreamProject":"node-test-commit-windows-fanned","upstreamUrl":"job/node-test-commit-windows-fanned/"},{"upstreamBuild":72669,"upstreamProject":"node-test-commit","upstreamUrl":"job/node-test-commit/"},{"upstreamBuild":60790,"upstreamProject":"node-test-pull-request","upstreamUrl":"job/node-test-pull-request/"},{"prId":"54142"}],"tap":{"ok":false,"name":"wpt/test-streams","id":1003,"buffered":false,"tapError":null,"skip":false,"todo":false,"previous":null,"plan":null,"diag":{"severity":"fail","exitcode":3221226356,"stack":"[SKIPPED] idlharness-shadowrealm.window.js: ShadowRealm support is not enabled\n[SKIPPED] queuing-strategies-size-function-per-global.window.js: Browser-specific test\n[SKIPPED] readable-streams\\cross-realm-crash.window.js: Browser-specific test\n[SKIPPED] readable-streams\\owning-type-video-frame.any.js: Browser-specific test\n[SKIPPED] readable-streams\\read-task-handling.window.js: Browser-specific test\n[SKIPPED] transferable\\deserialize-error.window.js: Browser-specific test\n[SKIPPED] transferable\\transfer-with-messageport.window.js: Browser-specific test\n[SKIPPED] transform-streams\\invalid-realm.tentative.window.js: Browser-specific test\n[PASS] a signal argument 'null' should cause pipeTo() to reject\n[PASS] a signal argument 'AbortSignal' should cause pipeTo() to reject\n[PASS] a signal argument 'true' should cause pipeTo() to reject\n[PASS] a signal argument '-1' should cause pipeTo() to reject\n[PASS] a signal argument '[object AbortSignal]' should cause pipeTo() to reject\n[PASS] an aborted signal should cause the writable stream to reject with an AbortError\n[PASS] (reason: 'null') all the error objects should be the same object\n[PASS] (reason: 'undefined') all the error objects should be the same object\n[PASS] (reason: 'error1: error1') all the error objects should be the same object\n[PASS] preventCancel should prevent canceling the readable\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; fulfilled cancel promise\n[PASS] preventAbort should prevent aborting the readable\n[PASS] preventCancel and preventAbort should prevent canceling the readable and aborting the readable\n[PASS] Closing must be propagated backward: starts closed; preventCancel omitted; rejected cancel promise\n[PASS] (reason: 'null') abort should prevent further reads\n[PASS] (reason: 'undefined') abort should prevent further reads\n[PASS] Closing must be propagated backward: starts closed; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] (reason: 'error1: error1') abort should prevent further reads\n[PASS] Closing must be propagated backward: starts closed; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] (reason: 'null') all pending writes should complete on abort\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] (reason: 'undefined') all pending writes should complete on abort\n[PASS] Closing must be propagated backward: starts closed; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] (reason: 'error1: error1') all pending writes should complete on abort\n[PASS] a rejection from underlyingSource.cancel() should be returned by pipeTo()\n[PASS] a rejection from underlyingSink.abort() should be returned by pipeTo()\n[PASS] Closing must be propagated backward: starts closed; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] a rejection from underlyingSink.abort() should be preferred to one from underlyingSource.cancel()\n[PASS] abort signal takes priority over closed readable\n[PASS] abort signal takes priority over errored readable\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true (truthy)\n[PASS] abort signal takes priority over closed writable\n[PASS] abort signal takes priority over errored writable\n[PASS] abort should do nothing after the readable is closed\n[PASS] abort should do nothing after the readable is errored\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated backward: starts closed; preventCancel = a (truthy)\n[PASS] abort should do nothing after the readable is errored, even with pending writes\n[PASS] Closing must be propagated backward: starts closed; preventCancel = 1 (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = Symbol() (truthy)\n[PASS] Closing must be propagated backward: starts closed; preventCancel = [object Object] (truthy)\n[PASS] abort should do nothing after the writable is errored\n[PASS] Closing must be propagated forward: starts closed; preventClose omitted; rejected close promise\n[PASS] Piping from a non-empty ReadableStream into a WritableStream that does not desire chunks, but then does\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true\n[PASS] Closing must be propagated backward: starts closed; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] pipeTo on a teed readable byte stream should only be aborted when both branches are aborted\n[PASS] Errors must be propagated backward: starts errored; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = undefined (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = null (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = false (falsy); fulfilled close promise\n[PASS] Piping from an empty ReadableStream into a WritableStream that does not desire chunks, but then the readable stream becomes non-empty and the writable stream starts desiring chunks\n[PASS] Closing must be propagated forward: starts closed; preventClose = 0 (falsy); fulfilled close promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = undefined (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = null (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = false (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = -0 (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = NaN (falsy); fulfilled abort promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = -0 (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = NaN (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose =  (falsy); fulfilled close promise\n[PASS] Closing must be propagated forward: starts closed; preventClose = true (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = a (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = 1 (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = Symbol() (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = [object Object] (truthy)\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true\n[PASS] Closing must be propagated forward: starts closed; preventClose = true, preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = undefined (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = null (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = false (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = -0 (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = NaN (falsy); fulfilled cancel promise\n[PASS] Piping from a ReadableStream to a WritableStream that desires more chunks before finishing with previous ones\n[PASS] Errors must be propagated forward: starts errored; preventAbort =  (falsy); fulfilled abort promise\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = a (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = 1 (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = Symbol() (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = [object Object] (truthy)\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true\n[PASS] Errors must be propagated forward: starts errored; preventAbort = true, preventCancel = true, preventClose = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel =  (falsy); fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = a (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = 1 (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = Symbol() (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = [object Object] (truthy)\n[PASS] Errors must be propagated backward: becomes errored before piping due to write, preventCancel = true; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored before piping due to write; preventCancel = true, preventAbort = true, preventClose = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = false; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored during piping due to write, but async; preventCancel = true\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; fulfilled close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose omitted; rejected close promise\n[PASS] Closing must be propagated forward: becomes closed asynchronously; dest never desires chunks; preventClose = true\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = false; rejected abort promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; fulfilled cancel promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; fulfilled close promise\n[PASS] Errors must be propagated forward: becomes errored while empty; preventAbort = true\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel omitted; rejected cancel promise\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose omitted; rejected close promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated backward: becomes errored after piping; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel omitted (but cancel is never called)\n[PASS] Errors must be propagated backward: becomes errored after piping due to last write; source is closed; preventCancel = true\n[PASS] Closing must be propagated forward: becomes closed after one chunk; preventClose = true\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Piping to a WritableStream that does not consume the writes fast enough exerts backpressure on the ReadableStream\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; fulfilled cancel promise\n[PASS] Errors must be propagated forward: becomes errored while empty; dest never desires chunks; preventAbort = true\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; preventClose = true\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = false; rejected cancel promise\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write\n[PASS] Errors must be propagated backward: becomes errored after piping; dest never desires chunks; preventCancel = true\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; fulfilled cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel omitted; rejected cancel promise\n[PASS] Errors must be propagated backward: becomes errored before piping via abort; preventCancel = true\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; fulfilled abort promise\n[PASS] Errors must be propagated backward: erroring via the controller errors once pending write completes\n[PASS] Closing must be propagated forward: shutdown must not occur until the final write completes; becomes closed after first write; preventClose = true\n[PASS] Closing must be propagated forward: erroring the writable while flushing pending writes should error pipeTo\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = false; rejected abort promise\n[PASS] idl_test validation\n[PASS] ReadableStreamDefaultReader includes ReadableStreamGenericReader: member names are unique\n[PASS] ReadableStreamBYOBReader includes ReadableStreamGenericReader: member names are unique\n[PASS] Errors must be propagated forward: becomes errored after one chunk; preventAbort = true\n[PASS] ReadableStream interface: existence and properties of interface object\n[PASS] ReadableStream interface object length\n[PASS] ReadableStream interface object name\n[PASS] ReadableStream interface: existence and properties of interface prototype object\n[PASS] ReadableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStream interface: operation from(any)\n[PASS] ReadableStream interface: operation getReader(optional ReadableStreamGetReaderOptions)\n[PASS] ReadableStream interface: operation pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\n[PASS] ReadableStream interface: operation tee()\n[PASS] ReadableStream interface: async iterable<any>\n[PASS] ReadableStream must be primary interface of new ReadableStream()\n[PASS] Stringification of new ReadableStream()\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"from(any)\" with the proper type\n[PASS] ReadableStream interface: calling from(any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"locked\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStream interface: calling cancel(optional any) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"getReader(optional ReadableStreamGetReaderOptions)\" with the proper type\n[PASS] ReadableStream interface: calling getReader(optional ReadableStreamGetReaderOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeThrough(ReadableWritablePair, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: calling pipeThrough(ReadableWritablePair, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"pipeTo(WritableStream, optional StreamPipeOptions)\" with the proper type\n[PASS] ReadableStream interface: new ReadableStream() must inherit property \"tee()\" with the proper type\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; fulfilled abort promise\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultReader interface object length\n[PASS] ReadableStreamDefaultReader interface object name\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultReader interface: operation releaseLock()\n[PASS] ReadableStreamDefaultReader must be primary interface of (new ReadableStream()).getReader()\n[PASS] Stringification of (new ReadableStream()).getReader()\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"read()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: (new ReadableStream()).getReader() must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultReader interface: calling cancel(optional any) on (new ReadableStream()).getReader() with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBReader interface object length\n[PASS] ReadableStreamBYOBReader interface object name\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBReader interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBReader interface: operation releaseLock()\n[PASS] ReadableStreamBYOBReader must be primary interface of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] Stringification of (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' })\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"read(ArrayBufferView, optional ReadableStreamBYOBReaderReadOptions)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"releaseLock()\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"closed\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) must inherit property \"cancel(optional any)\" with the proper type\n[PASS] ReadableStreamBYOBReader interface: calling cancel(optional any) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface object\n[PASS] ReadableStreamDefaultController interface object length\n[PASS] ReadableStreamDefaultController interface object name\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamDefaultController interface: operation close()\n[PASS] ReadableStreamDefaultController interface: operation enqueue(optional any)\n[PASS] ReadableStreamDefaultController interface: operation error(optional any)\n[PASS] ReadableStreamDefaultController must be primary interface of self.readableStreamDefaultController\n[PASS] Stringification of self.readableStreamDefaultController\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"close()\" with the proper type\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling enqueue(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultController interface: self.readableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableStreamDefaultController interface: calling error(optional any) on self.readableStreamDefaultController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: existence and properties of interface object\n[PASS] ReadableByteStreamController interface object length\n[PASS] ReadableByteStreamController interface object name\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableByteStreamController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableByteStreamController interface: operation close()\n[PASS] ReadableByteStreamController interface: operation enqueue(ArrayBufferView)\n[PASS] ReadableByteStreamController interface: operation error(optional any)\n[PASS] ReadableByteStreamController must be primary interface of self.readableByteStreamController\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = false; rejected abort promise\n[PASS] Stringification of self.readableByteStreamController\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"byobRequest\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"desiredSize\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"close()\" with the proper type\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"enqueue(ArrayBufferView)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling enqueue(ArrayBufferView) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableByteStreamController interface: self.readableByteStreamController must inherit property \"error(optional any)\" with the proper type\n[PASS] ReadableByteStreamController interface: calling error(optional any) on self.readableByteStreamController with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface object\n[PASS] ReadableStreamBYOBRequest interface object length\n[PASS] ReadableStreamBYOBRequest interface object name\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ReadableStreamBYOBRequest interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ReadableStreamBYOBRequest interface: operation respond(unsigned long long)\n[PASS] ReadableStreamBYOBRequest interface: operation respondWithNewView(ArrayBufferView)\n[PASS] ReadableStreamBYOBRequest must be primary interface of self.readableStreamByobRequest\n[PASS] Stringification of self.readableStreamByobRequest\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"view\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respond(unsigned long long)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respond(unsigned long long) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[PASS] ReadableStreamBYOBRequest interface: self.readableStreamByobRequest must inherit property \"respondWithNewView(ArrayBufferView)\" with the proper type\n[PASS] ReadableStreamBYOBRequest interface: calling respondWithNewView(ArrayBufferView) on self.readableStreamByobRequest with too few arguments must throw TypeError\n[EXPECTED_FAILURE][FAIL] enqueue() must not synchronously call write algorithm\nassert_false: write algorithm must not run synchronously expected false got true\n    at Test.<anonymous> (C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\fixtures\\wpt\\streams\\piping\\general-addition.any.js:14:3)\n    at process.processTicksAndRejections (node:internal/process/task_queues:95:5)\nCommand: C:\\workspace\\node-test-binary-windows-js-suites\\node\\Release\\node.exe  C:\\workspace\\node-test-binary-windows-js-suites\\node\\test\\wpt\\test-streams.js 'piping\\general-addition.any.js'\n\n[PASS] WritableStream interface: existence and properties of interface object\n[PASS] WritableStream interface object length\n[PASS] WritableStream interface object name\n[PASS] WritableStream interface: existence and properties of interface prototype object\n[PASS] WritableStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStream interface: operation getWriter()\n[PASS] Piping must lock both the ReadableStream and WritableStream\n[PASS] WritableStream must be primary interface of new WritableStream()\n[PASS] Stringification of new WritableStream()\n[PASS] WritableStream interface: new WritableStream() must inherit property \"locked\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStream interface: calling abort(optional any) on new WritableStream() with too few arguments must throw TypeError\n[PASS] WritableStream interface: new WritableStream() must inherit property \"close()\" with the proper type\n[PASS] WritableStream interface: new WritableStream() must inherit property \"getWriter()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface object\n[PASS] WritableStreamDefaultWriter interface object length\n[PASS] WritableStreamDefaultWriter interface object name\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultWriter interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] WritableStreamDefaultWriter interface: operation releaseLock()\n[PASS] WritableStreamDefaultWriter must be primary interface of (new WritableStream()).getWriter()\n[PASS] Stringification of (new WritableStream()).getWriter()\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"closed\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"desiredSize\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"ready\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"abort(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling abort(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"close()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"releaseLock()\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: (new WritableStream()).getWriter() must inherit property \"write(optional any)\" with the proper type\n[PASS] WritableStreamDefaultWriter interface: calling write(optional any) on (new WritableStream()).getWriter() with too few arguments must throw TypeError\n[PASS] WritableStreamDefaultController interface: existence and properties of interface object\n[PASS] WritableStreamDefaultController interface object length\n[PASS] WritableStreamDefaultController interface object name\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] WritableStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Piping finishing must unlock both the ReadableStream and WritableStream\n[PASS] pipeTo must check the brand of its ReadableStream this value\n[PASS] pipeTo must check the brand of its WritableStream argument\n[PASS] pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream\n[PASS] Errors must be propagated forward: becomes errored after one chunk; dest never desires chunks; preventAbort = true\n[PASS] pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream\n[PASS] WritableStreamDefaultController interface: operation error(optional any)\n[PASS] WritableStreamDefaultController must be primary interface of self.writableStreamDefaultController\n[PASS] Stringification of self.writableStreamDefaultController\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"signal\" with the proper type\n[PASS] WritableStreamDefaultController interface: self.writableStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] WritableStreamDefaultController interface: calling error(optional any) on self.writableStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStream interface: existence and properties of interface object\n[PASS] TransformStream interface object length\n[PASS] TransformStream interface object name\n[PASS] TransformStream interface: existence and properties of interface prototype object\n[PASS] TransformStream interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStream interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] Piping from a ReadableStream from which lots of chunks are synchronously readable\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes\n[PASS] TransformStream must be primary interface of new TransformStream()\n[PASS] Stringification of new TransformStream()\n[PASS] TransformStream interface: new TransformStream() must inherit property \"readable\" with the proper type\n[PASS] TransformStream interface: new TransformStream() must inherit property \"writable\" with the proper type\n[PASS] TransformStreamDefaultController interface: existence and properties of interface object\n[PASS] TransformStreamDefaultController interface object length\n[PASS] TransformStreamDefaultController interface object name\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] TransformStreamDefaultController interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] TransformStreamDefaultController interface: operation enqueue(optional any)\n[PASS] TransformStreamDefaultController interface: operation error(optional any)\n[PASS] TransformStreamDefaultController interface: operation terminate()\n[PASS] TransformStreamDefaultController must be primary interface of self.transformStreamDefaultController\n[PASS] Stringification of self.transformStreamDefaultController\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"desiredSize\" with the proper type\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"enqueue(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling enqueue(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"error(optional any)\" with the proper type\n[PASS] TransformStreamDefaultController interface: calling error(optional any) on self.transformStreamDefaultController with too few arguments must throw TypeError\n[PASS] TransformStreamDefaultController interface: self.transformStreamDefaultController must inherit property \"terminate()\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface object\n[PASS] ByteLengthQueuingStrategy interface object length\n[PASS] ByteLengthQueuingStrategy interface object name\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] ByteLengthQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] ByteLengthQueuingStrategy must be primary interface of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new ByteLengthQueuingStrategy({ highWaterMark: 5 })\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] ByteLengthQueuingStrategy interface: new ByteLengthQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] CountQueuingStrategy interface: existence and properties of interface object\n[PASS] CountQueuingStrategy interface object length\n[PASS] CountQueuingStrategy interface object name\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's \"constructor\" property\n[PASS] CountQueuingStrategy interface: existence and properties of interface prototype object's @@unscopables property\n[PASS] CountQueuingStrategy must be primary interface of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] Stringification of new CountQueuingStrategy({ highWaterMark: 5 })\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"highWaterMark\" with the proper type\n[PASS] CountQueuingStrategy interface: new CountQueuingStrategy({ highWaterMark: 5 }) must inherit property \"size\" with the proper type\n[PASS] ReadableStream interface: attribute locked\n[PASS] ReadableStreamDefaultController interface: attribute desiredSize\n[PASS] ReadableByteStreamController interface: attribute byobRequest\n[PASS] ReadableByteStreamController interface: attribute desiredSize\n[PASS] ReadableStreamBYOBRequest interface: attribute view\n[PASS] WritableStream interface: attribute locked\n[PASS] WritableStreamDefaultWriter interface: attribute desiredSize\n[PASS] WritableStreamDefaultController interface: attribute signal\n[PASS] TransformStream interface: attribute readable\n[PASS] TransformStream interface: attribute writable\n[PASS] TransformStreamDefaultController interface: attribute desiredSize\n[PASS] ByteLengthQueuingStrategy interface: attribute highWaterMark\n[PASS] ByteLengthQueuingStrategy interface: attribute size\n[PASS] CountQueuingStrategy interface: attribute highWaterMark\n[PASS] CountQueuingStrategy interface: attribute size\n[PASS] idl_test setup\n[PASS] ReadableStream interface: operation cancel(optional any)\n[PASS] ReadableStream interface: operation pipeTo(WritableStream, optional StreamPipeOptions)\n[PASS] ReadableStream interface: calling pipeTo(WritableStream, optional StreamPipeOptions) on new ReadableStream() with too few arguments must throw TypeError\n[PASS] ReadableStreamDefaultReader interface: operation read()\n[PASS] ReadableStreamDefaultReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: operation read(ArrayBufferView, optional ReadableStreamBYOBReaderReadOptions)\n[PASS] ReadableStreamBYOBReader interface: operation cancel(optional any)\n[PASS] ReadableStreamBYOBReader interface: calling read(ArrayBufferView, optional ReadableStreamBYOBReaderReadOptions) on (new ReadableStream({ type: 'bytes' })).getReader({ mode: 'byob' }) with too few arguments must throw TypeError\n[PASS] WritableStream interface: operation abort(optional any)\n[PASS] WritableStream interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation abort(optional any)\n[PASS] WritableStreamDefaultWriter interface: operation close()\n[PASS] WritableStreamDefaultWriter interface: operation write(optional any)\n[PASS] ReadableStreamDefaultReader interface: attribute closed\n[PASS] ReadableStreamBYOBReader interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute closed\n[PASS] WritableStreamDefaultWriter interface: attribute ready\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; preventAbort = true\n[PASS] Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write\n[PASS] an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is true\n[PASS] an undefined rejection from write should cause pipeTo() to reject when preventCancel is false\n[PASS] pipeTo() should reject if an option getter grabs a writer\n[PASS] pipeTo() promise should resolve if null is passed\n[PASS] Errors must be propagated forward: shutdown must not occur until the final write completes; becomes errored after first write; preventAbort = true\n[PASS] pipeThrough should not call pipeTo on this\n[PASS] pipeThrough should not call pipeTo on the ReadableStream prototype\n[PASS] pipeThrough should brand-check this and not allow 'null'\n[PASS] pipeThrough should brand-check readable and not allow 'null'\n[PASS] pipeThrough should brand-check this and not allow 'undefined'\n[PASS] Piping from an errored readable stream to an erroring writable stream\n[PASS] pipeThrough should brand-check readable and not allow 'undefined'\n[PASS] pipeThrough should brand-check this and not allow '0'\n[PASS] pipeThrough should brand-check readable and not allow '0'\n[PASS] pipeThrough should brand-check this and not allow 'NaN'\n[PASS] pipeThrough should brand-check readable and not allow 'NaN'\n[PASS] pipeThrough should brand-check this and not allow 'true'\n[PASS] pipeThrough should brand-check readable and not allow 'true'\n[PASS] pipeThrough should brand-check this and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check readable and not allow 'ReadableStream'\n[PASS] pipeThrough should brand-check this and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check readable and not allow '[object ReadableStream]'\n[PASS] pipeThrough should brand-check writable and not allow 'null'\n[PASS] pipeThrough should brand-check writable and not allow 'undefined'\n[PASS] pipeThrough should brand-check writable and not allow '0'\n[PASS] pipeThrough should brand-check writable and not allow 'NaN'\n[PASS] pipeThrough should brand-check writable and not allow 'true'\n[PASS] pipeThrough should brand-check writable and not allow 'WritableStream'\n[PASS] pipeThrough should brand-check writable and not allow '[object WritableStream]'\n[PASS] pipeThrough should rethrow errors from accessing readable or writable\n[PASS] invalid values of signal should throw; specifically 'null'\n[PASS] invalid values of signal should throw; specifically '0'\n[PASS] invalid values of signal should throw; specifically 'NaN'\n[PASS] invalid values of signal should throw; specifically 'true'\n[PASS] invalid values of signal should throw; specifically 'AbortSignal'\n[PASS] invalid values of signal should throw; specifically '[object AbortSignal]'\n[PASS] Piping from an errored readable stream to an errored writable stream\n[PASS] Piping from an errored readable stream to an erroring writable stream; preventAbort = true\n[PASS] Piping from an errored readable stream to an errored writable stream; preventAbort = true\n[PASS] Piping from an errored readable stream to a closing writable stream\n[PASS] pipeThrough should accept a real AbortSignal\n[PASS] pipeThrough should throw if this is locked\n[PASS] pipeThrough should throw if writable is locked\n[PASS] pipeThrough should not care if readable is locked\n[PASS] pipeThrough() should throw if an option getter grabs a writer\n[PASS] pipeThrough() should not throw if option is null\n[PASS] pipeThrough() should not throw if signal is undefined\n[PASS] pipeThrough() should throw if readable/writable getters throw\n[PASS] Piping from an errored readable stream to a closed writable stream\n[PASS] Piping from a closed readable stream to an erroring writable stream\n[PASS] Piping through a duck-typed pass-through transform stream should work\n[PASS] Piping from a closed readable stream to an errored writable stream\n[PASS] Piping from a closed readable stream to a closed writable stream\n[PASS] Piping through a transform errored on the writable end does not cause an unhandled promise rejection\n[PASS] preventCancel should work\n[PASS] preventClose should work\n[PASS] piping should not be observable\n[PASS] preventAbort should work\n[PASS] tee should not be observable\n[PASS] Piping through an identity transform stream should close the destination when the source closes\n[PASS] pipeThrough should stop after getting preventAbort throws\n[PASS] pipeThrough should stop after getting preventCancel throws\n[PASS] pipeThrough should stop after getting preventClose throws\n[PASS] pipeThrough should stop after getting signal throws\n[PASS] pipeTo should stop after getting preventAbort throws\n[PASS] pipeTo should stop after getting preventCancel throws\n[PASS] pipeTo should stop after getting preventClose throws\n[PASS] pipeTo should stop after getting signal throws\n[PASS] ReadableStream with byte source: enqueuing an already-detached buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length buffer throws\n[PASS] ReadableStream with byte source: enqueuing a zero-length view on a non-zero-length buffer throws\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a undefined ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a null ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a fake ReadableByteStreamController and a real view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a undefined view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a null view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a fake view\n[PASS] ReadableStreamBYOBRequest constructor should throw when passed a real ReadableByteStreamController and a real view\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respond() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is zero-length on a non-zero-length buffer (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a different offset (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (autoAllocateChunkSize)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view has a larger length (in the readable state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer is zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view is non-zero-length (in the closed state)\n[PASS] ReadableStream with byte source: respondWithNewView() throws if the supplied view's buffer has a different length (in the closed state)\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the readable state)\n[PASS] ReadableStream with byte source: enqueue() throws if the BYOB request's buffer has been detached (in the closed state)\n[PASS] ReadableStream with byte source: read()ing from a closed stream still transfers the buffer\n[PASS] ReadableStream with byte source: read()ing from a stream with queued chunks still transfers the buffer\n[PASS] ReadableStream with byte source: reading into an already-detached buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length buffer rejects\n[PASS] ReadableStream with byte source: reading into a zero-length view on a non-zero-length buffer rejects\n[PASS] CountQueuingStrategy: Can construct a with a valid high water mark\n[PASS] getReader({mode: \"byob\"}) throws on non-bytes streams\n[PASS] ReadableStream with byte source can be constructed with no errors\n[PASS] CountQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] CountQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] CountQueuingStrategy: size is the same function across all instances\n[PASS] CountQueuingStrategy: size should have the right name\n[PASS] enqueue after detaching byobRequest.view.buffer should throw\n[PASS] getReader({mode}) must perform ToString()\n[PASS] CountQueuingStrategy: subclassing should work correctly\n[PASS] CountQueuingStrategy: size should not have a prototype property\n[PASS] ByteLengthQueuingStrategy: Can construct a with a valid high water mark\n[PASS] ReadableStream with byte source: start() throws an exception\n[PASS] ReadableStream with byte source: desiredSize when closed\n[PASS] ReadableStream with byte source: desiredSize when errored\n[PASS] ReadableStream with byte source: pull() function is not callable\n[PASS] ByteLengthQueuingStrategy: Constructor behaves as expected with strange arguments\n[PASS] ByteLengthQueuingStrategy: highWaterMark constructor values are converted per the unrestricted double rules\n[PASS] ByteLengthQueuingStrategy: size is the same function across all instances\n[PASS] ByteLengthQueuingStrategy: size should have the right name\n[PASS] ByteLengthQueuingStrategy: subclassing should work correctly\n[PASS] ByteLengthQueuingStrategy: size should not have a prototype property\n[PASS] CountQueuingStrategy: size should not be a constructor\n[PASS] ByteLengthQueuingStrategy: size should not be a constructor\n[PASS] CountQueuingStrategy: size should have the right length\n[PASS] ByteLengthQueuingStrategy: size should have the right length\n[PASS] ReadableStream with byte source: Throw if close()-ed more than once\n[PASS] ReadableStream with byte source: Throw on enqueue() after close()\n[PASS] CountQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ReadableStream with byte source: autoAllocateChunkSize cannot be 0\n[PASS] ReadableStreamBYOBReader can be constructed directly\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream argument\n[PASS] ReadableStreamBYOBReader constructor requires an unlocked ReadableStream\n[PASS] ReadableStreamBYOBReader constructor requires a ReadableStream with type \"bytes\"\n[PASS] ByteLengthQueuingStrategy: size behaves as expected with strange arguments\n[PASS] ReadableStream constructor should not accept a strategy with a size defined if type is \"bytes\"\n[PASS] ReadableStream with byte source: Construct and expect start and pull being called\n[PASS] ReadableStream with byte source: No automatic pull call if start doesn't finish\n[PASS] ReadableStream with byte source: Construct with highWaterMark of 0\n[PASS] ReadableStream with byte source: getReader(), then releaseLock()\n[PASS] ReadableStream with byte source: getReader() with mode set to byob, then releaseLock()\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that closing a stream does not release a BYOB reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a reader automatically\n[PASS] ReadableStream with byte source: Test that erroring a stream does not release a BYOB reader automatically\n(node:2412) TimeoutNaNWarning: NaN is not a number.\nTimeout duration was set to 1.\n(Use `node --trace-warnings ...` to show where the warning was created)"},"time":1283.044,"fullname":"wpt/test-streams","closingTestPoint":false}}]}